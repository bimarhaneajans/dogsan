{"version":3,"file":"ej2-file-utils.umd.min.js","sources":["../src/encoding.js","../src/save.js","../src/xml-writer.js","../src/stream-writer.js"],"sourcesContent":["/**\n * Encoding class: Contains the details about encoding type, whether to write a Unicode byte order mark (BOM).\n * ```typescript\n * let encoding : Encoding = new Encoding();\n * encoding.type = 'Utf8';\n * encoding.getBytes('Encoding', 0, 5);\n * ```\n */\nvar Encoding = /** @class */ (function () {\n    /**\n     * Initializes a new instance of the Encoding class. A parameter specifies whether to write a Unicode byte order mark\n     * @param  {boolean} includeBom?-true to specify that a Unicode byte order mark is written; otherwise, false.\n     */\n    function Encoding(includeBom) {\n        this.emitBOM = true;\n        this.encodingType = 'Ansi';\n        this.initBOM(includeBom);\n    }\n    Object.defineProperty(Encoding.prototype, \"includeBom\", {\n        /**\n         * Gets a value indicating whether to write a Unicode byte order mark\n         * @returns boolean- true to specify that a Unicode byte order mark is written; otherwise, false\n         */\n        get: function () {\n            return this.emitBOM;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Encoding.prototype, \"type\", {\n        /**\n         * Gets the encoding type.\n         * @returns EncodingType\n         */\n        get: function () {\n            return this.encodingType;\n        },\n        /**\n         * Sets the encoding type.\n         * @param  {EncodingType} value\n         */\n        set: function (value) {\n            this.encodingType = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Initialize the includeBom to emit BOM or Not\n     * @param  {boolean} includeBom\n     */\n    Encoding.prototype.initBOM = function (includeBom) {\n        if (includeBom === undefined || includeBom === null) {\n            this.emitBOM = true;\n        }\n        else {\n            this.emitBOM = includeBom;\n        }\n    };\n    /**\n     * Calculates the number of bytes produced by encoding the characters in the specified string\n     * @param  {string} chars - The string containing the set of characters to encode\n     * @returns {number} - The number of bytes produced by encoding the specified characters\n     */\n    Encoding.prototype.getByteCount = function (chars) {\n        var byteCount = 0;\n        validateNullOrUndefined(chars, 'string');\n        if (chars === '') {\n            var byte = this.utf8Len(chars.charCodeAt(0));\n            return byte;\n        }\n        if (this.type === null || this.type === undefined) {\n            this.type = 'Ansi';\n        }\n        return this.getByteCountInternal(chars, 0, chars.length);\n    };\n    /**\n     * Return the Byte of character\n     * @param  {number} codePoint\n     * @returns {number}\n     */\n    Encoding.prototype.utf8Len = function (codePoint) {\n        var bytes = codePoint <= 0x7F ? 1 :\n            codePoint <= 0x7FF ? 2 :\n                codePoint <= 0xFFFF ? 3 :\n                    codePoint <= 0x1FFFFF ? 4 : 0;\n        return bytes;\n    };\n    /**\n     * for 4 byte character return surrogate pair true, otherwise false\n     * @param  {number} codeUnit\n     * @returns {boolean}\n     */\n    Encoding.prototype.isHighSurrogate = function (codeUnit) {\n        return codeUnit >= 0xD800 && codeUnit <= 0xDBFF;\n    };\n    /**\n     * for 4byte character generate the surrogate pair\n     * @param  {number} highCodeUnit\n     * @param  {number} lowCodeUnit\n     */\n    Encoding.prototype.toCodepoint = function (highCodeUnit, lowCodeUnit) {\n        highCodeUnit = (0x3FF & highCodeUnit) << 10;\n        var u = highCodeUnit | (0x3FF & lowCodeUnit);\n        return u + 0x10000;\n    };\n    /**\n     * private method to get the byte count for specific charindex and count\n     * @param  {string} chars\n     * @param  {number} charIndex\n     * @param  {number} charCount\n     */\n    Encoding.prototype.getByteCountInternal = function (chars, charIndex, charCount) {\n        var byteCount = 0;\n        if (this.encodingType === 'Utf8' || this.encodingType === 'Unicode') {\n            var isUtf8 = this.encodingType === 'Utf8';\n            for (var i = 0; i < charCount; i++) {\n                var charCode = chars.charCodeAt(isUtf8 ? charIndex : charIndex++);\n                if (this.isHighSurrogate(charCode)) {\n                    if (isUtf8) {\n                        var high = charCode;\n                        var low = chars.charCodeAt(++charIndex);\n                        byteCount += this.utf8Len(this.toCodepoint(high, low));\n                    }\n                    else {\n                        byteCount += 4;\n                        ++i;\n                    }\n                }\n                else {\n                    if (isUtf8) {\n                        byteCount += this.utf8Len(charCode);\n                    }\n                    else {\n                        byteCount += 2;\n                    }\n                }\n                if (isUtf8) {\n                    charIndex++;\n                }\n            }\n            return byteCount;\n        }\n        else {\n            byteCount = charCount;\n            return byteCount;\n        }\n    };\n    /**\n     * Encodes a set of characters from the specified string into the ArrayBuffer.\n     * @param  {string} s- The string containing the set of characters to encode\n     * @param  {number} charIndex-The index of the first character to encode.\n     * @param  {number} charCount- The number of characters to encode.\n     * @returns {ArrayBuffer} - The ArrayBuffer that contains the resulting sequence of bytes.\n     */\n    Encoding.prototype.getBytes = function (s, charIndex, charCount) {\n        validateNullOrUndefined(s, 'string');\n        validateNullOrUndefined(charIndex, 'charIndex');\n        validateNullOrUndefined(charCount, 'charCount');\n        if (charIndex < 0 || charCount < 0) {\n            throw new RangeError('Argument Out Of Range Exception: charIndex or charCount is less than zero');\n        }\n        if (s.length - charIndex < charCount) {\n            throw new RangeError('Argument Out Of Range Exception: charIndex and charCount do not denote a valid range in string');\n        }\n        var bytes;\n        if (s === '') {\n            bytes = new ArrayBuffer(0);\n            return bytes;\n        }\n        if (this.type === null || this.type === undefined) {\n            this.type = 'Ansi';\n        }\n        var byteCount = this.getByteCountInternal(s, charIndex, charCount);\n        switch (this.type) {\n            case 'Utf8':\n                bytes = this.getBytesOfUtf8Encoding(byteCount, s, charIndex, charCount);\n                return bytes;\n            case 'Unicode':\n                bytes = this.getBytesOfUnicodeEncoding(byteCount, s, charIndex, charCount);\n                return bytes;\n            default:\n                bytes = this.getBytesOfAnsiEncoding(byteCount, s, charIndex, charCount);\n                return bytes;\n        }\n    };\n    /**\n     * Decodes a sequence of bytes from the specified ArrayBuffer into the string.\n     * @param  {ArrayBuffer} bytes- The ArrayBuffer containing the sequence of bytes to decode.\n     * @param  {number} index- The index of the first byte to decode.\n     * @param  {number} count- The number of bytes to decode.\n     * @returns {string} - The string that contains the resulting set of characters.\n     */\n    Encoding.prototype.getString = function (bytes, index, count) {\n        validateNullOrUndefined(bytes, 'bytes');\n        validateNullOrUndefined(index, 'index');\n        validateNullOrUndefined(count, 'count');\n        if (index < 0 || count < 0) {\n            throw new RangeError('Argument Out Of Range Exception: index or count is less than zero');\n        }\n        if (bytes.byteLength - index < count) {\n            throw new RangeError('Argument Out Of Range Exception: index and count do not denote a valid range in bytes');\n        }\n        if (bytes.byteLength === 0 || count === 0) {\n            return '';\n        }\n        if (this.type === null || this.type === undefined) {\n            this.type = 'Ansi';\n        }\n        var out = '';\n        var byteCal = new Uint8Array(bytes);\n        switch (this.type) {\n            case 'Utf8':\n                var s = this.getStringOfUtf8Encoding(byteCal, index, count);\n                return s;\n            case 'Unicode':\n                var byteUnicode = new Uint16Array(bytes);\n                out = this.getStringofUnicodeEncoding(byteUnicode, index, count);\n                return out;\n            default:\n                var j = index;\n                for (var i = 0; i < count; i++) {\n                    var c = byteCal[j];\n                    out += String.fromCharCode(c); // 1 byte(ASCII) character                  \n                    j++;\n                }\n                return out;\n        }\n    };\n    Encoding.prototype.getBytesOfAnsiEncoding = function (byteCount, s, charIndex, charCount) {\n        var bytes = new ArrayBuffer(byteCount);\n        var bufview = new Uint8Array(bytes);\n        var k = 0;\n        for (var i = 0; i < charCount; i++) {\n            var charcode = s.charCodeAt(charIndex++);\n            if (charcode < 0x800) {\n                bufview[k] = charcode;\n            }\n            else {\n                bufview[k] = 63; //replacement character '?'\n            }\n            k++;\n        }\n        return bytes;\n    };\n    Encoding.prototype.getBytesOfUtf8Encoding = function (byteCount, s, charIndex, charCount) {\n        var bytes = new ArrayBuffer(byteCount);\n        var uint = new Uint8Array(bytes);\n        var index = charIndex;\n        var j = 0;\n        for (var i = 0; i < charCount; i++) {\n            var charcode = s.charCodeAt(index);\n            if (charcode <= 0x7F) { // 1 byte character 2^7\n                uint[j] = charcode;\n            }\n            else if (charcode < 0x800) { // 2 byte character 2^11\n                uint[j] = 0xc0 | (charcode >> 6);\n                uint[++j] = 0x80 | (charcode & 0x3f);\n            }\n            else if ((charcode < 0xd800 || charcode >= 0xe000)) { // 3 byte character 2^16        \n                uint[j] = 0xe0 | (charcode >> 12);\n                uint[++j] = 0x80 | ((charcode >> 6) & 0x3f);\n                uint[++j] = 0x80 | (charcode & 0x3f);\n            }\n            else {\n                uint[j] = 0xef;\n                uint[++j] = 0xbf;\n                uint[++j] = 0xbd; // U+FFFE \"replacement character\"\n            }\n            ++j;\n            ++index;\n        }\n        return bytes;\n    };\n    Encoding.prototype.getBytesOfUnicodeEncoding = function (byteCount, s, charIndex, charCount) {\n        var bytes = new ArrayBuffer(byteCount);\n        var uint16 = new Uint16Array(bytes);\n        for (var i = 0; i < charCount; i++) {\n            var charcode = s.charCodeAt(i);\n            uint16[i] = charcode;\n        }\n        return bytes;\n    };\n    Encoding.prototype.getStringOfUtf8Encoding = function (byteCal, index, count) {\n        var j = 0;\n        var i = index;\n        var s = '';\n        for (j; j < count; j++) {\n            var c = byteCal[i++];\n            while (i > byteCal.length) {\n                return s;\n            }\n            if (c > 127) {\n                if (c > 191 && c < 224 && i < count) {\n                    c = (c & 31) << 6 | byteCal[i] & 63;\n                }\n                else if (c > 223 && c < 240 && i < byteCal.byteLength) {\n                    c = (c & 15) << 12 | (byteCal[i] & 63) << 6 | byteCal[++i] & 63;\n                }\n                else if (c > 239 && c < 248 && i < byteCal.byteLength) {\n                    c = (c & 7) << 18 | (byteCal[i] & 63) << 12 | (byteCal[++i] & 63) << 6 | byteCal[++i] & 63;\n                }\n                ++i;\n            }\n            s += String.fromCharCode(c); // 1 byte(ASCII) character                          \n        }\n        return s;\n    };\n    Encoding.prototype.getStringofUnicodeEncoding = function (byteUni, index, count) {\n        if (count > byteUni.length) {\n            throw new RangeError('ArgumentOutOfRange_Count');\n        }\n        var byte16 = new Uint16Array(count);\n        var out = '';\n        for (var i = 0; i < count && i < byteUni.length; i++) {\n            byte16[i] = byteUni[index++];\n        }\n        out = String.fromCharCode.apply(null, byte16);\n        return out;\n    };\n    /**\n     * To clear the encoding instance\n     * @return {void}\n     */\n    Encoding.prototype.destroy = function () {\n        this.emitBOM = undefined;\n        this.encodingType = undefined;\n    };\n    return Encoding;\n}());\nexport { Encoding };\n/**\n * To check the object is null or undefined and throw error if it is null or undefined\n * @param {Object} value - object to check is null or undefined\n * @return {boolean}\n * @throws {ArgumentException} - if the value is null or undefined\n * @private\n */\nexport function validateNullOrUndefined(value, message) {\n    if (value === null || value === undefined) {\n        throw new Error('ArgumentException: ' + message + ' cannot be null or undefined');\n    }\n}\n","/**\n * Save class provide method to save file\n * ```typescript\n * let blob : Blob = new Blob([''], { type: 'text/plain' });\n * Save.save('fileName.txt',blob);\n */\nvar Save = /** @class */ (function () {\n    /**\n     * Initialize new instance of {save}\n     */\n    function Save() {\n        // tslint:disable\n    }\n    /**\n     * Saves the file with specified name and sends the file to client browser\n     * @param  {string} fileName- file name to save.\n     * @param  {Blob} buffer- the content to write in file\n     * @param  {boolean} isMicrosoftBrowser- specify whether microsoft browser or not\n     * @returns {void}\n     */\n    Save.save = function (fileName, buffer) {\n        if (fileName === null || fileName === undefined || fileName === '') {\n            throw new Error('ArgumentException: fileName cannot be undefined, null or empty');\n        }\n        var extension = fileName.substring(fileName.lastIndexOf('.') + 1, fileName.length);\n        var mimeType = this.getMimeType(extension);\n        if (mimeType !== '') {\n            buffer = new Blob([buffer], { type: mimeType });\n        }\n        if (this.isMicrosoftBrowser) {\n            navigator.msSaveBlob(buffer, fileName);\n        }\n        else {\n            var downloadLink = document.createElementNS('http://www.w3.org/1999/xhtml', 'a');\n            this.saveInternal(fileName, extension, buffer, downloadLink, 'download' in downloadLink);\n        }\n    };\n    Save.saveInternal = function (fileName, extension, buffer, downloadLink, hasDownloadAttribute) {\n        if (hasDownloadAttribute) {\n            downloadLink.download = fileName;\n            var dataUrl_1 = window.URL.createObjectURL(buffer);\n            downloadLink.href = dataUrl_1;\n            var event_1 = document.createEvent('MouseEvent');\n            event_1.initEvent('click', true, true);\n            downloadLink.dispatchEvent(event_1);\n            setTimeout(function () {\n                window.URL.revokeObjectURL(dataUrl_1);\n                dataUrl_1 = undefined;\n            });\n        }\n        else {\n            if (extension !== 'docx' && extension !== 'xlsx') {\n                var url = window.URL.createObjectURL(buffer);\n                var isPopupBlocked = window.open(url, '_blank');\n                if (!isPopupBlocked) {\n                    window.location.href = url;\n                }\n            }\n            else {\n                var reader_1 = new FileReader();\n                reader_1.onloadend = function () {\n                    var isPopupBlocked = window.open(reader_1.result, '_blank');\n                    if (!isPopupBlocked) {\n                        window.location.href = reader_1.result;\n                    }\n                };\n                reader_1.readAsDataURL(buffer);\n            }\n        }\n    };\n    /**\n     *\n     * @param {string} extension - get mime type of the specified extension\n     * @private\n     */\n    Save.getMimeType = function (extension) {\n        var mimeType = '';\n        switch (extension) {\n            case 'html':\n                mimeType = 'text/html';\n                break;\n            case 'pdf':\n                mimeType = 'application/pdf';\n                break;\n            case 'docx':\n                mimeType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';\n                break;\n            case 'xlsx':\n                mimeType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';\n                break;\n            case 'txt':\n                mimeType = 'text/plain';\n                break;\n        }\n        return mimeType;\n    };\n    return Save;\n}());\nexport { Save };\n","import { Save } from './save';\n/**\n * XmlWriter class provide method to create XML data\n */\nvar XmlWriter = /** @class */ (function () {\n    /**\n     * Initialize new instance of {XmlWriter}\n     */\n    function XmlWriter() {\n        this.contentPos = 0;\n        this.bufferText = '';\n        this.bufferBlob = new Blob([''], { type: 'text/plain' });\n        this.currentState = 'Initial';\n        this.namespaceStack = [];\n        this.namespaceStack.push(new Namespace());\n        this.namespaceStack[0].set('xmlns', 'http://www.w3.org/2000/xmlns/', 'Special');\n        this.namespaceStack.push(new Namespace());\n        this.namespaceStack[1].set('xml', 'http://www.w3.org/XML/1998/namespace', 'Special');\n        this.namespaceStack.push(new Namespace());\n        this.namespaceStack[2].set('', '', 'Implied');\n        this.elementStack = [];\n        this.elementStack.push(new XmlElement());\n        this.elementStack[0].set('', '', '', this.namespaceStack.length - 1);\n        this.attributeStack = [];\n        Save.isMicrosoftBrowser = !(!navigator.msSaveBlob);\n    }\n    Object.defineProperty(XmlWriter.prototype, \"buffer\", {\n        /**\n         * Gets the content written to the {XmlWriter} as Blob.\n         * @returns {Blob}\n         */\n        get: function () {\n            this.flush();\n            return this.bufferBlob;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Writes processing instruction with a space between the name and text\n     * @param {string} name - name of the processing instruction\n     * @param {string} text - text to write in the processing instruction\n     * @throws ArgumentException\n     * @throws InvalidArgumentException\n     * @throws InvalidOperationException\n     */\n    XmlWriter.prototype.writeProcessingInstruction = function (name, text) {\n        if (name === undefined || name === null || name.length === 0) {\n            throw new Error('ArgumentException: name should not be undefined, null or empty');\n        }\n        this.checkName(name);\n        if (text === undefined || text === null) {\n            text = '';\n        }\n        if (name.length === 3 && name === 'xml') {\n            if (this.currentState !== 'Initial') {\n                // tslint:disable-next-line:max-line-length\n                throw new Error('InvalidArgumentException: Cannot write XML declaration.WriteStartDocument method has already written it');\n            }\n        }\n        if (this.currentState !== 'Initial' || this.bufferBlob === undefined) {\n            throw new Error('InvalidOperationException: Wrong Token');\n        }\n        else {\n            this.writeStartDocument();\n            this.writeProcessingInstructionInternal(name, text);\n        }\n    };\n    /**\n     * Writes Xml declaration with version and standalone attribute\n     * @param {boolean} standalone - if true it write standalone=yes else standalone=no\n     * @throws InvalidOperation\n     */\n    XmlWriter.prototype.writeStartDocument = function (standalone) {\n        if (this.currentState !== 'Initial' || this.bufferBlob === undefined) {\n            throw new Error('InvalidOperationException: Wrong Token');\n        }\n        this.currentState = 'StartDocument';\n        this.rawText('<?xml version=\"1.0\" encoding=\"utf-8');\n        if (standalone !== null && standalone !== undefined) {\n            this.rawText('\" standalone=\"');\n            this.rawText(standalone ? 'yes' : 'no');\n        }\n        this.rawText('\"?>');\n    };\n    /**\n     * Closes any open tag or attribute and write the state back to start\n     */\n    XmlWriter.prototype.writeEndDocument = function () {\n        while (this.elementStack.length - 1 > 0) {\n            this.writeEndElement();\n        }\n        this.currentState = 'EndDocument';\n        this.flush();\n    };\n    /**\n     * Writes the specified start tag and associates it with the given namespace and prefix.\n     * @param {string} prefix - namespace prefix of element\n     * @param {string} localName -localName of element\n     * @param {string} namespace - namespace URI associate with element\n     * @throws ArgumentException\n     * @throws InvalidOperationException\n     */\n    XmlWriter.prototype.writeStartElement = function (prefix, localName, namespace) {\n        if (this.bufferBlob === undefined) {\n            throw new Error('InvalidOperationException: Wrong Token');\n        }\n        if (localName === undefined || localName === null || localName.length === 0) {\n            throw new Error('ArgumentException: localName cannot be undefined, null or empty');\n        }\n        this.checkName(localName);\n        if (this.currentState === 'Initial') {\n            this.writeStartDocument();\n        }\n        if (this.currentState === 'StartElement') {\n            this.startElementContent();\n        }\n        this.currentState = 'StartElement';\n        if (prefix === undefined || prefix === null) {\n            if (namespace !== undefined && namespace !== null) {\n                prefix = this.lookupPrefix(namespace);\n            }\n            if (prefix === undefined || prefix === null) {\n                prefix = '';\n            }\n        }\n        else if (prefix.length > 0) {\n            if (namespace === undefined || namespace === null) {\n                namespace = this.lookupNamespace(prefix);\n            }\n            if (namespace === undefined || namespace === null || (namespace !== undefined && namespace.length === 0)) {\n                throw new Error('ArgumentException: Cannot use a prefix with an empty namespace');\n            }\n        }\n        if (namespace === undefined || namespace === null) {\n            namespace = this.lookupNamespace(prefix);\n        }\n        this.writeStartElementInternal(prefix, localName, namespace);\n    };\n    /**\n     * Closes one element and pop corresponding namespace scope\n     */\n    XmlWriter.prototype.writeEndElement = function () {\n        if (this.currentState === 'StartElement') {\n            this.startElementContent();\n            this.currentState = 'ElementContent';\n        }\n        else if (this.currentState === 'ElementContent') {\n            this.currentState = 'ElementContent';\n        }\n        this.currentState = 'EndElement';\n        var top = this.elementStack.length - 1;\n        this.writeEndElementInternal(this.elementStack[top].prefix, this.elementStack[top].localName);\n        this.namespaceStack.splice(this.elementStack[top].previousTop + 1);\n        this.elementStack.splice(top);\n        if (this.bufferText.length > 10240) {\n            this.flush();\n        }\n    };\n    /**\n     * Writes an element with the specified prefix, local name, namespace URI, and value.\n     * @param {string} prefix - namespace prefix of element\n     * @param {string} localName - localName of element\n     * @param {string} namespace - namespace URI associate with element\n     * @param {string} value - value of element\n     */\n    XmlWriter.prototype.writeElementString = function (prefix, localName, namespace, value) {\n        this.writeStartElement(prefix, localName, namespace);\n        if (value !== undefined && value !== null && value.length !== 0) {\n            this.writeString(value);\n        }\n        this.writeEndElement();\n    };\n    /**\n     * Writes out the attribute with the specified prefix, local name, namespace URI, and value\n     * @param {string} prefix - namespace prefix of element\n     * @param {string} localName - localName of element\n     * @param {string} namespace - namespace URI associate with element\n     * @param {string} value - value of element\n     */\n    XmlWriter.prototype.writeAttributeString = function (prefix, localName, namespace, value) {\n        this.writeStartAttribute(prefix, localName, namespace, value);\n        this.writeStringInternal(value, true);\n        this.writeEndAttribute();\n    };\n    /**\n     * Writes the given text content\n     * @param {string} text - text to write\n     * @throws InvalidOperationException\n     */\n    XmlWriter.prototype.writeString = function (text) {\n        this.writeInternal(text, false);\n    };\n    /**\n     * Write given text as raw data\n     * @param {string} text - text to write\n     * @throws InvalidOperationException\n     */\n    XmlWriter.prototype.writeRaw = function (text) {\n        this.writeInternal(text, true);\n    };\n    XmlWriter.prototype.writeInternal = function (text, isRawString) {\n        if (text === undefined || text === null) {\n            return;\n        }\n        else {\n            if (this.currentState !== 'StartElement' && this.currentState !== 'ElementContent') {\n                throw new Error('InvalidOperationException: Wrong Token');\n            }\n            if (this.currentState === 'StartElement') {\n                this.startElementContent();\n            }\n            this.currentState = 'ElementContent';\n            if (isRawString) {\n                this.rawText(text);\n            }\n            else {\n                this.writeStringInternal(text, false);\n            }\n        }\n    };\n    /**\n     * Saves the file with specified name and sends the file to client browser\n     * @param {string} fileName - file name\n     */\n    XmlWriter.prototype.save = function (fileName) {\n        while (this.elementStack.length - 1 > 0) {\n            this.writeEndElement();\n        }\n        if (this.bufferText !== '') {\n            this.flush();\n        }\n        Save.save(fileName, this.buffer);\n    };\n    /**\n     * Releases the resources used by XmlWriter.\n     */\n    XmlWriter.prototype.destroy = function () {\n        this.bufferBlob = undefined;\n        for (var i = 0; i < this.namespaceStack.length; i++) {\n            this.namespaceStack[i].destroy();\n        }\n        this.namespaceStack = [];\n        for (var i = 0; i < this.elementStack.length; i++) {\n            this.elementStack[i].destroy();\n        }\n        this.elementStack = [];\n        this.bufferText = '';\n        this.contentPos = 0;\n    };\n    XmlWriter.prototype.flush = function () {\n        if (this.bufferBlob === undefined) {\n            return;\n        }\n        this.bufferBlob = new Blob([this.bufferBlob, this.bufferText], { type: 'text/plain' });\n        this.bufferText = '';\n    };\n    XmlWriter.prototype.writeProcessingInstructionInternal = function (name, text) {\n        this.bufferText += '<?';\n        this.rawText(name);\n        if (text.length > 0) {\n            this.bufferText += ' ';\n            text = text.replace(/\\?\\>/g, '? >');\n            this.bufferText += text;\n        }\n        this.bufferText += '?';\n        this.bufferText += '>';\n    };\n    XmlWriter.prototype.writeStartAttribute = function (prefix, localName, namespace, value) {\n        if (localName === undefined || localName === null || localName.length === 0) {\n            if (prefix === 'xmlns') {\n                localName = 'xmlns';\n                prefix = '';\n            }\n            else {\n                throw new Error('ArgumentException: localName cannot be undefined, null or empty');\n            }\n        }\n        if (this.currentState !== 'StartElement') {\n            throw new Error('InvalidOperationException: Wrong Token');\n        }\n        this.checkName(localName);\n        this.writeStartAttributePrefixAndNameSpace(prefix, localName, namespace, value);\n    };\n    XmlWriter.prototype.writeStartAttributePrefixAndNameSpace = function (prefix, localName, namespace, value) {\n        if (prefix === undefined || prefix === null) {\n            if (namespace !== undefined && namespace !== null) {\n                if (!(localName === 'xmlns' && namespace === 'http://www.w3.org/2000/xmlns/')) {\n                    prefix = this.lookupPrefix(namespace);\n                }\n            }\n            if (prefix === undefined || prefix === null) {\n                prefix = '';\n            }\n        }\n        if (namespace === undefined || namespace === null) {\n            if (prefix !== undefined && prefix !== null && prefix.length > 0) {\n                namespace = this.lookupNamespace(prefix);\n            }\n            if (namespace === undefined || namespace === null) {\n                namespace = '';\n            }\n        }\n        this.writeStartAttributeSpecialAttribute(prefix, localName, namespace, value);\n    };\n    XmlWriter.prototype.writeStartAttributeSpecialAttribute = function (prefix, localName, namespace, value) {\n        if (prefix.length === 0) {\n            if (localName[0] === 'x' && localName === 'xmlns') {\n                this.skipPushAndWrite(prefix, localName, namespace);\n                this.pushNamespaceExplicit('', value);\n                return;\n            }\n            else if (namespace.length > 0) {\n                prefix = this.lookupPrefix(namespace);\n            }\n        }\n        else {\n            if (prefix[0] === 'x') {\n                if (prefix === 'xmlns') {\n                    this.skipPushAndWrite(prefix, localName, namespace);\n                    this.pushNamespaceExplicit(localName, value);\n                    return;\n                }\n                else if (prefix === 'xml') {\n                    if (localName === 'space' || localName === 'lang') {\n                        this.skipPushAndWrite(prefix, localName, namespace);\n                        return;\n                    }\n                }\n            }\n            if (namespace.length === 0) {\n                prefix = '';\n            }\n        }\n        if (prefix !== undefined && prefix !== null && prefix.length !== 0) {\n            this.pushNamespaceImplicit(prefix, namespace);\n        }\n        this.skipPushAndWrite(prefix, localName, namespace);\n    };\n    XmlWriter.prototype.writeEndAttribute = function () {\n        this.currentState = 'StartElement';\n        this.bufferText += '\"';\n    };\n    XmlWriter.prototype.writeStartElementInternal = function (prefix, localName, namespace) {\n        this.bufferText += '<';\n        if (prefix.length > 0) {\n            this.rawText(prefix);\n            this.bufferText += ':';\n        }\n        this.rawText(localName);\n        var top = this.elementStack.length;\n        this.elementStack.push(new XmlElement());\n        this.elementStack[top].set(prefix, localName, namespace, this.namespaceStack.length - 1);\n        this.pushNamespaceImplicit(prefix, namespace);\n        for (var i = 0; i < this.attributeStack.length; i++) {\n            this.attributeStack[i].destroy();\n        }\n        this.attributeStack = [];\n    };\n    XmlWriter.prototype.writeEndElementInternal = function (prefix, localName) {\n        if (this.contentPos !== this.bufferText.length + 1) {\n            this.bufferText += '</';\n            if (prefix !== undefined && prefix !== null && prefix.length !== 0) {\n                this.rawText(prefix);\n                this.bufferText += ':';\n            }\n            this.rawText(localName);\n            this.bufferText += '>';\n        }\n        else {\n            this.bufferText = this.bufferText.substring(0, this.bufferText.length - 1);\n            this.bufferText += ' />';\n        }\n    };\n    XmlWriter.prototype.writeStartAttributeInternal = function (prefix, localName, namespaceName) {\n        this.bufferText += ' ';\n        if (prefix !== undefined && prefix !== null && prefix.length > 0) {\n            this.rawText(prefix);\n            this.bufferText += ':';\n        }\n        this.rawText(localName);\n        this.bufferText += '=';\n        this.bufferText += '\"';\n    };\n    XmlWriter.prototype.writeNamespaceDeclaration = function (prefix, namespaceUri) {\n        this.writeStartNamespaceDeclaration(prefix);\n        this.writeStringInternal(namespaceUri, true);\n        this.bufferText += '\"';\n    };\n    XmlWriter.prototype.writeStartNamespaceDeclaration = function (prefix) {\n        if (prefix === undefined || prefix === null || prefix.length === 0) {\n            this.rawText(' xmlns=\\\"');\n        }\n        else {\n            this.rawText(' xmlns:');\n            this.rawText(prefix);\n            this.bufferText += '=';\n            this.bufferText += '\"';\n        }\n    };\n    XmlWriter.prototype.writeStringInternal = function (text, inAttributeValue) {\n        if (text === null || text === undefined) {\n            text = '';\n        }\n        var tempText = '';\n        text = text.replace(/\\&/g, '&amp;');\n        text = text.replace(/\\</g, '&lt;');\n        text = text.replace(/\\>/g, '&gt;');\n        if (inAttributeValue) {\n            text = text.replace(/\\\"/g, '&quot;');\n        }\n        this.bufferText += text;\n        if (!inAttributeValue) {\n            this.contentPos = 0;\n        }\n    };\n    XmlWriter.prototype.startElementContent = function () {\n        var start = this.elementStack[this.elementStack.length - 1].previousTop;\n        for (var i = this.namespaceStack.length - 1; i > start; i--) {\n            if (this.namespaceStack[i].kind === 'NeedToWrite') {\n                this.writeNamespaceDeclaration(this.namespaceStack[i].prefix, this.namespaceStack[i].namespaceUri);\n            }\n        }\n        this.bufferText += '>';\n        this.contentPos = this.bufferText.length + 1;\n    };\n    XmlWriter.prototype.rawText = function (text) {\n        this.bufferText += text;\n    };\n    XmlWriter.prototype.addNamespace = function (prefix, ns, kind) {\n        var top = this.namespaceStack.length;\n        this.namespaceStack.push(new Namespace());\n        this.namespaceStack[top].set(prefix, ns, kind);\n    };\n    XmlWriter.prototype.lookupPrefix = function (namespace) {\n        for (var i = this.namespaceStack.length - 1; i >= 0; i--) {\n            if (this.namespaceStack[i].namespaceUri === namespace) {\n                return this.namespaceStack[i].prefix;\n            }\n        }\n        return undefined;\n    };\n    XmlWriter.prototype.lookupNamespace = function (prefix) {\n        for (var i = this.namespaceStack.length - 1; i >= 0; i--) {\n            if (this.namespaceStack[i].prefix === prefix) {\n                return this.namespaceStack[i].namespaceUri;\n            }\n        }\n        return undefined;\n    };\n    XmlWriter.prototype.lookupNamespaceIndex = function (prefix) {\n        for (var i = this.namespaceStack.length - 1; i >= 0; i--) {\n            if (this.namespaceStack[i].prefix === prefix) {\n                return i;\n            }\n        }\n        return -1;\n    };\n    XmlWriter.prototype.pushNamespaceImplicit = function (prefix, ns) {\n        var kind;\n        var existingNsIndex = this.lookupNamespaceIndex(prefix);\n        if (existingNsIndex !== -1) {\n            if (existingNsIndex > this.elementStack[this.elementStack.length - 1].previousTop) {\n                if (this.namespaceStack[existingNsIndex].namespaceUri !== ns) {\n                    throw new Error('XmlException namespace Uri needs to be the same as the one that is already declared');\n                }\n                return;\n            }\n            else {\n                if (this.namespaceStack[existingNsIndex].kind === 'Special') {\n                    if (prefix === 'xml') {\n                        if (ns !== this.namespaceStack[existingNsIndex].namespaceUri) {\n                            throw new Error('InvalidArgumentException: Xml String');\n                        }\n                        else {\n                            kind = 'Implied';\n                        }\n                    }\n                    else {\n                        throw new Error('InvalidArgumentException: Prefix \"xmlns\" is reserved for use by XML.');\n                    }\n                }\n                else {\n                    kind = (this.namespaceStack[existingNsIndex].namespaceUri === ns) ? 'Implied' : 'NeedToWrite';\n                }\n            }\n        }\n        else {\n            if ((ns === 'http://www.w3.org/XML/1998/namespace' && prefix !== 'xml') ||\n                (ns === 'http://www.w3.org/2000/xmlns/' && prefix !== 'xmlns')) {\n                throw new Error('InvalidArgumentException');\n            }\n            kind = 'NeedToWrite';\n        }\n        this.addNamespace(prefix, ns, kind);\n    };\n    XmlWriter.prototype.pushNamespaceExplicit = function (prefix, ns) {\n        var existingNsIndex = this.lookupNamespaceIndex(prefix);\n        if (existingNsIndex !== -1) {\n            if (existingNsIndex > this.elementStack[this.elementStack.length - 1].previousTop) {\n                this.namespaceStack[existingNsIndex].kind = 'Written';\n                return;\n            }\n        }\n        this.addNamespace(prefix, ns, 'Written');\n        return;\n    };\n    XmlWriter.prototype.addAttribute = function (prefix, localName, namespaceName) {\n        var top = this.attributeStack.length;\n        this.attributeStack.push(new XmlAttribute());\n        this.attributeStack[top].set(prefix, localName, namespaceName);\n        for (var i = 0; i < top; i++) {\n            if (this.attributeStack[i].isDuplicate(prefix, localName, namespaceName)) {\n                throw new Error('XmlException: duplicate attribute name');\n            }\n        }\n    };\n    XmlWriter.prototype.skipPushAndWrite = function (prefix, localName, namespace) {\n        this.addAttribute(prefix, localName, namespace);\n        this.writeStartAttributeInternal(prefix, localName, namespace);\n    };\n    XmlWriter.prototype.checkName = function (text) {\n        var format = /[ !@#$%^&*()+\\=\\[\\]{};':\"\\\\|,<>\\/?]/;\n        if (format.test(text)) {\n            throw new Error('InvalidArgumentException: invalid name character');\n        }\n    };\n    return XmlWriter;\n}());\nexport { XmlWriter };\n/**\n * class for managing namespace collection\n */\nvar Namespace = /** @class */ (function () {\n    function Namespace() {\n    }\n    /**\n     * set value for current namespace instance\n     * @param {string} prefix namespace's prefix\n     * @param {string} namespaceUri namespace URI\n     * @param {string} kind namespace kind\n     */\n    Namespace.prototype.set = function (prefix, namespaceUri, kind) {\n        this.prefix = prefix;\n        this.namespaceUri = namespaceUri;\n        this.kind = kind;\n    };\n    /**\n     * Releases the resources used by Namespace\n     */\n    Namespace.prototype.destroy = function () {\n        this.prefix = undefined;\n        this.namespaceUri = undefined;\n        this.kind = undefined;\n    };\n    return Namespace;\n}());\nexport { Namespace };\n/**\n * class for managing element collection\n */\nvar XmlElement = /** @class */ (function () {\n    function XmlElement() {\n    }\n    /**\n     * set value of current element\n     * @param {string} prefix - element prefix\n     * @param {string} localName - element local name\n     * @param {string} namespaceUri -namespace URI\n     * @param {string} previousTop - previous namespace top\n     */\n    XmlElement.prototype.set = function (prefix, localName, namespaceUri, previousTop) {\n        this.previousTop = previousTop;\n        this.prefix = prefix;\n        this.namespaceUri = namespaceUri;\n        this.localName = localName;\n    };\n    /**\n     * Releases the resources used by XmlElement\n     */\n    XmlElement.prototype.destroy = function () {\n        this.previousTop = undefined;\n        this.prefix = undefined;\n        this.localName = undefined;\n        this.namespaceUri = undefined;\n    };\n    return XmlElement;\n}());\nexport { XmlElement };\n/**\n * class for managing attribute collection\n */\nvar XmlAttribute = /** @class */ (function () {\n    function XmlAttribute() {\n    }\n    /**\n     * set value of current attribute\n     * @param {string} prefix - namespace's prefix\n     * @param {string} namespaceUri - namespace URI\n     * @param {string} localName - attribute localName\n     */\n    XmlAttribute.prototype.set = function (prefix, localName, namespaceUri) {\n        this.prefix = prefix;\n        this.namespaceUri = namespaceUri;\n        this.localName = localName;\n    };\n    /**\n     * get whether the attribute is duplicate or not\n     * @param {string} prefix - namespace's prefix\n     * @param {string} namespaceUri - namespace URI\n     * @param {string} localName - attribute localName\n     */\n    XmlAttribute.prototype.isDuplicate = function (prefix, localName, namespaceUri) {\n        return ((this.localName === localName) && ((this.prefix === prefix) || (this.namespaceUri === namespaceUri)));\n    };\n    /**\n     * Releases the resources used by XmlAttribute\n     */\n    XmlAttribute.prototype.destroy = function () {\n        this.prefix = undefined;\n        this.namespaceUri = undefined;\n        this.localName = undefined;\n    };\n    return XmlAttribute;\n}());\nexport { XmlAttribute };\n","import { Encoding, validateNullOrUndefined } from './encoding';\nimport { Save } from './save';\n/**\n * StreamWriter class contains the implementation for writing characters to a file in a particular encoding\n * ```typescript\n * let writer = new StreamWriter();\n * writer.write('Hello World');\n * writer.save('Sample.txt');\n * writer.dispose();\n * ```\n */\nvar StreamWriter = /** @class */ (function () {\n    /**\n     * Initializes a new instance of the StreamWriter class by using the specified encoding.\n     * @param  {Encoding} encoding?- The character encoding to use.\n     */\n    function StreamWriter(encoding) {\n        this.bufferBlob = new Blob(['']);\n        this.bufferText = '';\n        this.init(encoding);\n        Save.isMicrosoftBrowser = !(!navigator.msSaveBlob);\n    }\n    Object.defineProperty(StreamWriter.prototype, \"buffer\", {\n        /**\n         * Gets the content written to the StreamWriter as Blob.\n         * @returns Blob\n         */\n        get: function () {\n            this.flush();\n            return this.bufferBlob;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StreamWriter.prototype, \"encoding\", {\n        /**\n         * Gets the encoding.\n         * @returns Encoding\n         */\n        get: function () {\n            return this.enc;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    StreamWriter.prototype.init = function (encoding) {\n        if (encoding === null || encoding === undefined) {\n            this.enc = new Encoding(false);\n            this.enc.type = 'Utf8';\n        }\n        else {\n            this.enc = encoding;\n            this.setBomByte();\n        }\n    };\n    /**\n     * Private method to set Byte Order Mark(BOM) value based on EncodingType\n     */\n    StreamWriter.prototype.setBomByte = function () {\n        if (this.encoding.includeBom) {\n            switch (this.encoding.type) {\n                case 'Unicode':\n                    var arrayUnicode = new ArrayBuffer(2);\n                    var uint8 = new Uint8Array(arrayUnicode);\n                    uint8[0] = 255;\n                    uint8[1] = 254;\n                    this.bufferBlob = new Blob([arrayUnicode]);\n                    break;\n                case 'Utf8':\n                    var arrayUtf8 = new ArrayBuffer(3);\n                    var utf8 = new Uint8Array(arrayUtf8);\n                    utf8[0] = 239;\n                    utf8[1] = 187;\n                    utf8[2] = 191;\n                    this.bufferBlob = new Blob([arrayUtf8]);\n                    break;\n                default:\n                    this.bufferBlob = new Blob(['']);\n                    break;\n            }\n        }\n    };\n    /**\n     * Saves the file with specified name and sends the file to client browser\n     * @param  {string} fileName - The file name to save\n     * @returns {void}\n     */\n    StreamWriter.prototype.save = function (fileName) {\n        if (this.bufferText !== '') {\n            this.flush();\n        }\n        Save.save(fileName, this.buffer);\n    };\n    /**\n     * Writes the specified string.\n     * @param  {string} value - The string to write. If value is null or undefined, nothing is written.\n     * @returns {void}\n     */\n    StreamWriter.prototype.write = function (value) {\n        if (this.encoding === undefined) {\n            throw new Error('Object Disposed Exception: current writer is disposed');\n        }\n        validateNullOrUndefined(value, 'string');\n        this.bufferText += value;\n        if (this.bufferText.length >= 10240) {\n            this.flush();\n        }\n    };\n    StreamWriter.prototype.flush = function () {\n        if (this.bufferText === undefined || this.bufferText === null || this.bufferText.length === 0) {\n            return;\n        }\n        var bufferArray = this.encoding.getBytes(this.bufferText, 0, this.bufferText.length);\n        this.bufferText = '';\n        this.bufferBlob = new Blob([this.bufferBlob, bufferArray]);\n    };\n    /**\n     * Writes the specified string followed by a line terminator\n     * @param  {string} value - The string to write. If value is null or undefined, nothing is written\n     * @returns {void}\n     */\n    StreamWriter.prototype.writeLine = function (value) {\n        if (this.encoding === undefined) {\n            throw new Error('Object Disposed Exception: current writer is disposed');\n        }\n        validateNullOrUndefined(value, 'string');\n        this.bufferText = this.bufferText + value + '\\r\\n';\n        if (this.bufferText.length >= 10240) {\n            this.flush();\n        }\n    };\n    /**\n     * Releases the resources used by the StreamWriter\n     * @returns {void}\n     */\n    StreamWriter.prototype.destroy = function () {\n        this.bufferBlob = undefined;\n        this.bufferText = undefined;\n        if (this.enc instanceof Encoding) {\n            this.enc.destroy();\n        }\n        this.enc = undefined;\n    };\n    return StreamWriter;\n}());\nexport { StreamWriter };\n"],"names":["validateNullOrUndefined","value","message","undefined","Error","Save","save","fileName","buffer","extension","substring","lastIndexOf","length","mimeType","this","getMimeType","Blob","type","isMicrosoftBrowser","navigator","msSaveBlob","downloadLink","document","createElementNS","saveInternal","hasDownloadAttribute","download","dataUrl_1","window","URL","createObjectURL","href","event_1","createEvent","initEvent","dispatchEvent","setTimeout","revokeObjectURL","url","open","location","reader_1","FileReader","onloadend","result","readAsDataURL","XmlWriter","contentPos","bufferText","bufferBlob","currentState","namespaceStack","push","Namespace","set","elementStack","XmlElement","attributeStack","Object","defineProperty","prototype","get","flush","enumerable","configurable","writeProcessingInstruction","name","text","checkName","writeStartDocument","writeProcessingInstructionInternal","standalone","rawText","writeEndDocument","writeEndElement","writeStartElement","prefix","localName","namespace","startElementContent","lookupPrefix","lookupNamespace","writeStartElementInternal","top","writeEndElementInternal","splice","previousTop","writeElementString","writeString","writeAttributeString","writeStartAttribute","writeStringInternal","writeEndAttribute","writeInternal","writeRaw","isRawString","destroy","i","replace","writeStartAttributePrefixAndNameSpace","writeStartAttributeSpecialAttribute","skipPushAndWrite","pushNamespaceExplicit","pushNamespaceImplicit","writeStartAttributeInternal","namespaceName","writeNamespaceDeclaration","namespaceUri","writeStartNamespaceDeclaration","inAttributeValue","start","kind","addNamespace","ns","lookupNamespaceIndex","existingNsIndex","addAttribute","XmlAttribute","isDuplicate","test","Encoding","includeBom","emitBOM","encodingType","initBOM","getByteCount","chars","utf8Len","charCodeAt","getByteCountInternal","codePoint","isHighSurrogate","codeUnit","toCodepoint","highCodeUnit","lowCodeUnit","charIndex","charCount","byteCount","isUtf8","charCode","high","low","getBytes","s","RangeError","ArrayBuffer","getBytesOfUtf8Encoding","getBytesOfUnicodeEncoding","getBytesOfAnsiEncoding","getString","bytes","index","count","byteLength","out","byteCal","Uint8Array","getStringOfUtf8Encoding","byteUnicode","Uint16Array","getStringofUnicodeEncoding","j","c","String","fromCharCode","bufview","k","charcode","uint","uint16","byteUni","byte16","apply","StreamWriter","encoding","init","enc","setBomByte","arrayUnicode","uint8","arrayUtf8","utf8","write","bufferArray","writeLine"],"mappings":"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"}