{"version":3,"file":"ej2-compression.min.js","sources":["../../src/compression-writer.js","../../src/zip-archive.js"],"sourcesContent":["import { Encoding } from '@syncfusion/ej2-file-utils';\n/**\n * array literal codes\n */\nvar ARR_LITERAL_CODES = new Int16Array(286);\nvar ARR_LITERAL_LENGTHS = new Uint8Array(286);\nvar ARR_DISTANCE_CODES = new Int16Array(30);\nvar ARR_DISTANCE_LENGTHS = new Uint8Array(30);\n/**\n * represent compression stream writer\n * ```typescript\n * let compressedWriter = new CompressedStreamWriter();\n * let text: string = 'Hello world!!!';\n * compressedWriter.write(text, 0, text.length);\n * compressedWriter.close();\n * ```\n */\nvar CompressedStreamWriter = /** @class */ (function () {\n    /**\n     * Initializes compressor and writes ZLib header if needed.\n     * @param {boolean} noWrap - optional if true, ZLib header and checksum will not be written.\n     */\n    function CompressedStreamWriter(noWrap) {\n        this.pendingBuffer = new Uint8Array(1 << 16);\n        this.pendingBufLength = 0;\n        this.pendingBufCache = 0;\n        this.pendingBufBitsInCache = 0;\n        this.bufferPosition = 0;\n        this.extraBits = 0;\n        this.currentHash = 0;\n        this.matchStart = 0;\n        this.matchLength = 0;\n        this.matchPrevAvail = false;\n        this.blockStart = 0;\n        this.stringStart = 0;\n        this.lookAhead = 0;\n        this.totalBytesIn = 0;\n        this.inputOffset = 0;\n        this.inputEnd = 0;\n        this.windowSize = 1 << 15;\n        this.windowMask = this.windowSize - 1;\n        this.hashSize = 1 << 15;\n        this.hashMask = this.hashSize - 1;\n        this.hashShift = Math.floor((15 + 3 - 1) / 3);\n        this.maxDist = this.windowSize - 262;\n        this.checkSum = 1;\n        this.noWrap = false;\n        if (!CompressedStreamWriter.isHuffmanTreeInitiated) {\n            CompressedStreamWriter.initHuffmanTree();\n            CompressedStreamWriter.isHuffmanTreeInitiated = true;\n        }\n        this.treeLiteral = new CompressorHuffmanTree(this, 286, 257, 15);\n        this.treeDistances = new CompressorHuffmanTree(this, 30, 1, 15);\n        this.treeCodeLengths = new CompressorHuffmanTree(this, 19, 4, 7);\n        this.arrDistances = new Uint16Array((1 << 14));\n        this.arrLiterals = new Uint8Array((1 << 14));\n        this.stream = [];\n        this.dataWindow = new Uint8Array(2 * this.windowSize);\n        this.hashHead = new Int16Array(this.hashSize);\n        this.hashPrevious = new Int16Array(this.windowSize);\n        this.blockStart = this.stringStart = 1;\n        this.noWrap = noWrap;\n        if (!noWrap) {\n            this.writeZLibHeader();\n        }\n    }\n    Object.defineProperty(CompressedStreamWriter.prototype, \"compressedData\", {\n        /**\n         * get compressed data\n         */\n        get: function () {\n            return this.stream;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CompressedStreamWriter.prototype, \"getCompressedString\", {\n        get: function () {\n            var compressedString = '';\n            if (this.stream !== undefined) {\n                for (var i = 0; i < this.stream.length; i++) {\n                    compressedString += String.fromCharCode.apply(null, this.stream[i]);\n                }\n            }\n            return compressedString;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Compresses data and writes it to the stream.\n     * @param {Uint8Array} data - data to compress\n     * @param {number} offset - offset in data\n     * @param {number} length - length of the data\n     * @returns {void}\n     */\n    CompressedStreamWriter.prototype.write = function (data, offset, length) {\n        if (data === undefined || data === null) {\n            throw new Error('ArgumentException: data cannot null or undefined');\n        }\n        var end = offset + length;\n        if (0 > offset || offset > end || end > data.length) {\n            throw new Error('ArgumentOutOfRangeException: Offset or length is incorrect');\n        }\n        if (typeof data === 'string') {\n            var encode = new Encoding(false);\n            encode.type = 'Utf8';\n            data = new Uint8Array(encode.getBytes(data, 0, data.length));\n            end = offset + data.length;\n        }\n        this.inputBuffer = data;\n        this.inputOffset = offset;\n        this.inputEnd = end;\n        if (!this.noWrap) {\n            this.checkSum = ChecksumCalculator.checksumUpdate(this.checkSum, this.inputBuffer, this.inputOffset, end);\n        }\n        while (!(this.inputEnd === this.inputOffset) || !(this.pendingBufLength === 0)) {\n            this.pendingBufferFlush();\n            this.compressData(false);\n        }\n    };\n    /**\n     * write ZLib header to the compressed data\n     * @return {void}\n     */\n    CompressedStreamWriter.prototype.writeZLibHeader = function () {\n        /* Initialize header.*/\n        var headerDate = (8 + (7 << 4)) << 8;\n        /* Save compression level.*/\n        headerDate |= ((5 >> 2) & 3) << 6;\n        /* Align header.*/\n        headerDate += 31 - (headerDate % 31);\n        /* Write header to stream.*/\n        this.pendingBufferWriteShortBytes(headerDate);\n    };\n    /**\n     *  Write Most Significant Bytes in to stream\n     * @param {number} s - check sum value\n     */\n    CompressedStreamWriter.prototype.pendingBufferWriteShortBytes = function (s) {\n        this.pendingBuffer[this.pendingBufLength++] = s >> 8;\n        this.pendingBuffer[this.pendingBufLength++] = s;\n    };\n    CompressedStreamWriter.prototype.compressData = function (finish) {\n        var success;\n        do {\n            this.fillWindow();\n            var canFlush = (finish && this.inputEnd === this.inputOffset);\n            success = this.compressSlow(canFlush, finish);\n        } while (this.pendingBufLength === 0 && success);\n        return success;\n    };\n    CompressedStreamWriter.prototype.compressSlow = function (flush, finish) {\n        if (this.lookAhead < 262 && !flush) {\n            return false;\n        }\n        while (this.lookAhead >= 262 || flush) {\n            if (this.lookAhead === 0) {\n                return this.lookAheadCompleted(finish);\n            }\n            if (this.stringStart >= 2 * this.windowSize - 262) {\n                this.slideWindow();\n            }\n            var prevMatch = this.matchStart;\n            var prevLen = this.matchLength;\n            if (this.lookAhead >= 3) {\n                this.discardMatch();\n            }\n            if (prevLen >= 3 && this.matchLength <= prevLen) {\n                prevLen = this.matchPreviousBest(prevMatch, prevLen);\n            }\n            else {\n                this.matchPreviousAvailable();\n            }\n            if (this.bufferPosition >= (1 << 14)) {\n                return this.huffmanIsFull(finish);\n            }\n        }\n        return true;\n    };\n    CompressedStreamWriter.prototype.discardMatch = function () {\n        var hashHead = this.insertString();\n        if (hashHead !== 0 && this.stringStart - hashHead <= this.maxDist && this.findLongestMatch(hashHead)) {\n            if (this.matchLength <= 5 && (this.matchLength === 3 && this.stringStart - this.matchStart > 4096)) {\n                this.matchLength = 3 - 1;\n            }\n        }\n    };\n    CompressedStreamWriter.prototype.matchPreviousAvailable = function () {\n        if (this.matchPrevAvail) {\n            this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 0xff);\n        }\n        this.matchPrevAvail = true;\n        this.stringStart++;\n        this.lookAhead--;\n    };\n    CompressedStreamWriter.prototype.matchPreviousBest = function (prevMatch, prevLen) {\n        this.huffmanTallyDist(this.stringStart - 1 - prevMatch, prevLen);\n        prevLen -= 2;\n        do {\n            this.stringStart++;\n            this.lookAhead--;\n            if (this.lookAhead >= 3) {\n                this.insertString();\n            }\n        } while (--prevLen > 0);\n        this.stringStart++;\n        this.lookAhead--;\n        this.matchPrevAvail = false;\n        this.matchLength = 3 - 1;\n        return prevLen;\n    };\n    CompressedStreamWriter.prototype.lookAheadCompleted = function (finish) {\n        if (this.matchPrevAvail) {\n            this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 0xff);\n        }\n        this.matchPrevAvail = false;\n        this.huffmanFlushBlock(this.dataWindow, this.blockStart, this.stringStart - this.blockStart, finish);\n        this.blockStart = this.stringStart;\n        return false;\n    };\n    CompressedStreamWriter.prototype.huffmanIsFull = function (finish) {\n        var len = this.stringStart - this.blockStart;\n        if (this.matchPrevAvail) {\n            len--;\n        }\n        var lastBlock = (finish && this.lookAhead === 0 && !this.matchPrevAvail);\n        this.huffmanFlushBlock(this.dataWindow, this.blockStart, len, lastBlock);\n        this.blockStart += len;\n        return !lastBlock;\n    };\n    CompressedStreamWriter.prototype.fillWindow = function () {\n        if (this.stringStart >= this.windowSize + this.maxDist) {\n            this.slideWindow();\n        }\n        while (this.lookAhead < 262 && this.inputOffset < this.inputEnd) {\n            var more = 2 * this.windowSize - this.lookAhead - this.stringStart;\n            if (more > this.inputEnd - this.inputOffset) {\n                more = this.inputEnd - this.inputOffset;\n            }\n            this.dataWindow.set(this.inputBuffer.subarray(this.inputOffset, this.inputOffset + more), this.stringStart + this.lookAhead);\n            this.inputOffset += more;\n            this.totalBytesIn += more;\n            this.lookAhead += more;\n        }\n        if (this.lookAhead >= 3) {\n            this.updateHash();\n        }\n    };\n    CompressedStreamWriter.prototype.slideWindow = function () {\n        this.dataWindow.set(this.dataWindow.subarray(this.windowSize, this.windowSize + this.windowSize), 0);\n        this.matchStart -= this.windowSize;\n        this.stringStart -= this.windowSize;\n        this.blockStart -= this.windowSize;\n        for (var i = 0; i < this.hashSize; ++i) {\n            var m = this.hashHead[i] & 0xffff;\n            this.hashHead[i] = (((m >= this.windowSize) ? (m - this.windowSize) : 0));\n        }\n        for (var i = 0; i < this.windowSize; i++) {\n            var m = this.hashPrevious[i] & 0xffff;\n            this.hashPrevious[i] = ((m >= this.windowSize) ? (m - this.windowSize) : 0);\n        }\n    };\n    CompressedStreamWriter.prototype.insertString = function () {\n        var match;\n        var hash = ((this.currentHash << this.hashShift) ^ this.dataWindow[this.stringStart + (3 - 1)]) & this.hashMask;\n        this.hashPrevious[this.stringStart & this.windowMask] = match = this.hashHead[hash];\n        this.hashHead[hash] = this.stringStart;\n        this.currentHash = hash;\n        return match & 0xffff;\n    };\n    CompressedStreamWriter.prototype.findLongestMatch = function (curMatch) {\n        var chainLen = 4096;\n        var niceLen = 258;\n        var scan = this.stringStart;\n        var match;\n        var bestEnd = this.stringStart + this.matchLength;\n        var bestLength = Math.max(this.matchLength, 3 - 1);\n        var limit = Math.max(this.stringStart - this.maxDist, 0);\n        var stringEnd = this.stringStart + 258 - 1;\n        var scanEnd1 = this.dataWindow[bestEnd - 1];\n        var scanEnd = this.dataWindow[bestEnd];\n        var data = this.dataWindow;\n        if (bestLength >= 32) {\n            chainLen >>= 2;\n        }\n        if (niceLen > this.lookAhead) {\n            niceLen = this.lookAhead;\n        }\n        do {\n            if (data[curMatch + bestLength] !== scanEnd ||\n                data[curMatch + bestLength - 1] !== scanEnd1 ||\n                data[curMatch] !== data[scan] ||\n                data[curMatch + 1] !== data[scan + 1]) {\n                continue;\n            }\n            match = curMatch + 2;\n            scan += 2;\n            /* tslint:disable */\n            while (data[++scan] === data[++match] && data[++scan] === data[++match] &&\n                data[++scan] === data[++match] && data[++scan] === data[++match] &&\n                data[++scan] === data[++match] && data[++scan] === data[++match] &&\n                data[++scan] === data[++match] && data[++scan] === data[++match] && scan < stringEnd) {\n                /* tslint:disable */\n            }\n            if (scan > bestEnd) {\n                this.matchStart = curMatch;\n                bestEnd = scan;\n                bestLength = scan - this.stringStart;\n                if (bestLength >= niceLen) {\n                    break;\n                }\n                scanEnd1 = data[bestEnd - 1];\n                scanEnd = data[bestEnd];\n            }\n            scan = this.stringStart;\n        } while ((curMatch = (this.hashPrevious[curMatch & this.windowMask] & 0xffff)) > limit && --chainLen !== 0);\n        this.matchLength = Math.min(bestLength, this.lookAhead);\n        return this.matchLength >= 3;\n    };\n    CompressedStreamWriter.prototype.updateHash = function () {\n        this.currentHash = (this.dataWindow[this.stringStart] << this.hashShift) ^ this.dataWindow[this.stringStart + 1];\n    };\n    CompressedStreamWriter.prototype.huffmanTallyLit = function (literal) {\n        this.arrDistances[this.bufferPosition] = 0;\n        this.arrLiterals[this.bufferPosition++] = literal;\n        this.treeLiteral.codeFrequencies[literal]++;\n        return this.bufferPosition >= (1 << 14);\n    };\n    CompressedStreamWriter.prototype.huffmanTallyDist = function (dist, len) {\n        this.arrDistances[this.bufferPosition] = dist;\n        this.arrLiterals[this.bufferPosition++] = (len - 3);\n        var lc = this.huffmanLengthCode(len - 3);\n        this.treeLiteral.codeFrequencies[lc]++;\n        if (lc >= 265 && lc < 285) {\n            this.extraBits += Math.floor((lc - 261) / 4);\n        }\n        var dc = this.huffmanDistanceCode(dist - 1);\n        this.treeDistances.codeFrequencies[dc]++;\n        if (dc >= 4) {\n            this.extraBits += Math.floor((dc / 2 - 1));\n        }\n        return this.bufferPosition >= (1 << 14);\n    };\n    CompressedStreamWriter.prototype.huffmanFlushBlock = function (stored, storedOffset, storedLength, lastBlock) {\n        this.treeLiteral.codeFrequencies[256]++;\n        this.treeLiteral.buildTree();\n        this.treeDistances.buildTree();\n        this.treeLiteral.calculateBLFreq(this.treeCodeLengths);\n        this.treeDistances.calculateBLFreq(this.treeCodeLengths);\n        this.treeCodeLengths.buildTree();\n        var blTreeCodes = 4;\n        for (var i = 18; i > blTreeCodes; i--) {\n            if (this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[i]] > 0) {\n                blTreeCodes = i + 1;\n            }\n        }\n        var opt_len = 14 + blTreeCodes * 3 + this.treeCodeLengths.getEncodedLength() +\n            this.treeLiteral.getEncodedLength() + this.treeDistances.getEncodedLength() + this.extraBits;\n        var static_len = this.extraBits;\n        for (var i = 0; i < 286; i++) {\n            static_len += this.treeLiteral.codeFrequencies[i] * ARR_LITERAL_LENGTHS[i];\n        }\n        for (var i = 0; i < 30; i++) {\n            static_len += this.treeDistances.codeFrequencies[i] * ARR_DISTANCE_LENGTHS[i];\n        }\n        if (opt_len >= static_len) {\n            // Force static trees.\n            opt_len = static_len;\n        }\n        if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {\n            this.huffmanFlushStoredBlock(stored, storedOffset, storedLength, lastBlock);\n        }\n        else if (opt_len == static_len) {\n            // Encode with static tree.\n            this.pendingBufferWriteBits((1 << 1) + (lastBlock ? 1 : 0), 3);\n            this.treeLiteral.setStaticCodes(ARR_LITERAL_CODES, ARR_LITERAL_LENGTHS);\n            this.treeDistances.setStaticCodes(ARR_DISTANCE_CODES, ARR_DISTANCE_LENGTHS);\n            this.huffmanCompressBlock();\n            this.huffmanReset();\n        }\n        else {\n            this.pendingBufferWriteBits((2 << 1) + (lastBlock ? 1 : 0), 3);\n            this.huffmanSendAllTrees(blTreeCodes);\n            this.huffmanCompressBlock();\n            this.huffmanReset();\n        }\n    };\n    CompressedStreamWriter.prototype.huffmanFlushStoredBlock = function (stored, storedOffset, storedLength, lastBlock) {\n        this.pendingBufferWriteBits((0 << 1) + (lastBlock ? 1 : 0), 3);\n        this.pendingBufferAlignToByte();\n        this.pendingBufferWriteShort(storedLength);\n        this.pendingBufferWriteShort(~storedLength);\n        this.pendingBufferWriteByteBlock(stored, storedOffset, storedLength);\n        this.huffmanReset();\n    };\n    CompressedStreamWriter.prototype.huffmanLengthCode = function (len) {\n        if (len === 255) {\n            return 285;\n        }\n        var code = 257;\n        while (len >= 8) {\n            code += 4;\n            len >>= 1;\n        }\n        return code + len;\n    };\n    CompressedStreamWriter.prototype.huffmanDistanceCode = function (distance) {\n        var code = 0;\n        while (distance >= 4) {\n            code += 2;\n            distance >>= 1;\n        }\n        return code + distance;\n    };\n    CompressedStreamWriter.prototype.huffmanSendAllTrees = function (blTreeCodes) {\n        this.treeCodeLengths.buildCodes();\n        this.treeLiteral.buildCodes();\n        this.treeDistances.buildCodes();\n        this.pendingBufferWriteBits(this.treeLiteral.treeLength - 257, 5);\n        this.pendingBufferWriteBits(this.treeDistances.treeLength - 1, 5);\n        this.pendingBufferWriteBits(blTreeCodes - 4, 4);\n        for (var rank = 0; rank < blTreeCodes; rank++) {\n            this.pendingBufferWriteBits(this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[rank]], 3);\n        }\n        this.treeLiteral.writeTree(this.treeCodeLengths);\n        this.treeDistances.writeTree(this.treeCodeLengths);\n    };\n    CompressedStreamWriter.prototype.huffmanReset = function () {\n        this.bufferPosition = 0;\n        this.extraBits = 0;\n        this.treeLiteral.reset();\n        this.treeDistances.reset();\n        this.treeCodeLengths.reset();\n    };\n    CompressedStreamWriter.prototype.huffmanCompressBlock = function () {\n        for (var i = 0; i < this.bufferPosition; i++) {\n            var literalLen = this.arrLiterals[i] & 255;\n            var dist = this.arrDistances[i];\n            if (dist-- !== 0) {\n                var lc = this.huffmanLengthCode(literalLen);\n                this.treeLiteral.writeCodeToStream(lc);\n                var bits = Math.floor((lc - 261) / 4);\n                if (bits > 0 && bits <= 5) {\n                    this.pendingBufferWriteBits(literalLen & ((1 << bits) - 1), bits);\n                }\n                var dc = this.huffmanDistanceCode(dist);\n                this.treeDistances.writeCodeToStream(dc);\n                bits = Math.floor(dc / 2 - 1);\n                if (bits > 0) {\n                    this.pendingBufferWriteBits(dist & ((1 << bits) - 1), bits);\n                }\n            }\n            else {\n                this.treeLiteral.writeCodeToStream(literalLen);\n            }\n        }\n        this.treeLiteral.writeCodeToStream(256);\n    };\n    /**\n     * write bits in to internal buffer\n     * @param {number} b - source of bits\n     * @param {number} count - count of bits to write\n     */\n    CompressedStreamWriter.prototype.pendingBufferWriteBits = function (b, count) {\n        var uint = new Uint32Array(1);\n        uint[0] = this.pendingBufCache | (b << this.pendingBufBitsInCache);\n        this.pendingBufCache = uint[0];\n        this.pendingBufBitsInCache += count;\n        this.pendingBufferFlushBits();\n    };\n    CompressedStreamWriter.prototype.pendingBufferFlush = function (isClose) {\n        this.pendingBufferFlushBits();\n        if (this.pendingBufLength > 0) {\n            var array = new Uint8Array(this.pendingBufLength);\n            array.set(this.pendingBuffer.subarray(0, this.pendingBufLength), 0);\n            this.stream.push(array);\n        }\n        this.pendingBufLength = 0;\n    };\n    CompressedStreamWriter.prototype.pendingBufferFlushBits = function () {\n        var result = 0;\n        while (this.pendingBufBitsInCache >= 8 && this.pendingBufLength < (1 << 16)) {\n            this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;\n            this.pendingBufCache >>= 8;\n            this.pendingBufBitsInCache -= 8;\n            result++;\n        }\n        return result;\n    };\n    CompressedStreamWriter.prototype.pendingBufferWriteByteBlock = function (data, offset, length) {\n        var array = data.subarray(offset, offset + length);\n        this.pendingBuffer.set(array, this.pendingBufLength);\n        this.pendingBufLength += length;\n    };\n    CompressedStreamWriter.prototype.pendingBufferWriteShort = function (s) {\n        this.pendingBuffer[this.pendingBufLength++] = s;\n        this.pendingBuffer[this.pendingBufLength++] = (s >> 8);\n    };\n    CompressedStreamWriter.prototype.pendingBufferAlignToByte = function () {\n        if (this.pendingBufBitsInCache > 0) {\n            this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;\n        }\n        this.pendingBufCache = 0;\n        this.pendingBufBitsInCache = 0;\n    };\n    /**\n     * Huffman Tree literal calculation\n     * @private\n     */\n    CompressedStreamWriter.initHuffmanTree = function () {\n        var i = 0;\n        while (i < 144) {\n            ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse((0x030 + i) << 8);\n            ARR_LITERAL_LENGTHS[i++] = 8;\n        }\n        while (i < 256) {\n            ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse((0x190 - 144 + i) << 7);\n            ARR_LITERAL_LENGTHS[i++] = 9;\n        }\n        while (i < 280) {\n            ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse((0x000 - 256 + i) << 9);\n            ARR_LITERAL_LENGTHS[i++] = 7;\n        }\n        while (i < 286) {\n            ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse((0x0c0 - 280 + i) << 8);\n            ARR_LITERAL_LENGTHS[i++] = 8;\n        }\n        for (i = 0; i < 30; i++) {\n            ARR_DISTANCE_CODES[i] = CompressorHuffmanTree.bitReverse(i << 11);\n            ARR_DISTANCE_LENGTHS[i] = 5;\n        }\n    };\n    /**\n     * close the stream and write all pending buffer in to stream\n     * @returns {void}\n     */\n    CompressedStreamWriter.prototype.close = function () {\n        do {\n            this.pendingBufferFlush(true);\n            if (!this.compressData(true)) {\n                this.pendingBufferFlush(true);\n                this.pendingBufferAlignToByte();\n                if (!this.noWrap) {\n                    this.pendingBufferWriteShortBytes(this.checkSum >> 16);\n                    this.pendingBufferWriteShortBytes(this.checkSum & 0xffff);\n                }\n                this.pendingBufferFlush(true);\n            }\n        } while (!(this.inputEnd === this.inputOffset) ||\n            !(this.pendingBufLength === 0));\n    };\n    /**\n     * release allocated un-managed resource\n     * @returns {void}\n     */\n    CompressedStreamWriter.prototype.destroy = function () {\n        this.stream = [];\n        this.stream = undefined;\n        this.pendingBuffer = undefined;\n        this.treeLiteral = undefined;\n        this.treeDistances = undefined;\n        this.treeCodeLengths = undefined;\n        this.arrLiterals = undefined;\n        this.arrDistances = undefined;\n        this.hashHead = undefined;\n        this.hashPrevious = undefined;\n        this.dataWindow = undefined;\n        this.inputBuffer = undefined;\n        this.pendingBufLength = undefined;\n        this.pendingBufCache = undefined;\n        this.pendingBufBitsInCache = undefined;\n        this.bufferPosition = undefined;\n        this.extraBits = undefined;\n        this.currentHash = undefined;\n        this.matchStart = undefined;\n        this.matchLength = undefined;\n        this.matchPrevAvail = undefined;\n        this.blockStart = undefined;\n        this.stringStart = undefined;\n        this.lookAhead = undefined;\n        this.totalBytesIn = undefined;\n        this.inputOffset = undefined;\n        this.inputEnd = undefined;\n        this.windowSize = undefined;\n        this.windowMask = undefined;\n        this.hashSize = undefined;\n        this.hashMask = undefined;\n        this.hashShift = undefined;\n        this.maxDist = undefined;\n        this.checkSum = undefined;\n        this.noWrap = undefined;\n    };\n    CompressedStreamWriter.isHuffmanTreeInitiated = false;\n    return CompressedStreamWriter;\n}());\nexport { CompressedStreamWriter };\n/**\n * represent the Huffman Tree\n */\nvar CompressorHuffmanTree = /** @class */ (function () {\n    /**\n     * Create new Huffman Tree\n     * @param {CompressedStreamWriter} writer instance\n     * @param {number} elementCount - element count\n     * @param {number} minCodes - minimum count\n     * @param {number} maxLength - maximum count\n     */\n    function CompressorHuffmanTree(writer, elementCount, minCodes, maxLength) {\n        this.writer = writer;\n        this.codeMinCount = minCodes;\n        this.maxLength = maxLength;\n        this.codeFrequency = new Uint16Array(elementCount);\n        this.lengthCount = new Int32Array(maxLength);\n    }\n    Object.defineProperty(CompressorHuffmanTree.prototype, \"treeLength\", {\n        get: function () {\n            return this.codeCount;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CompressorHuffmanTree.prototype, \"codeLengths\", {\n        get: function () {\n            return this.codeLength;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CompressorHuffmanTree.prototype, \"codeFrequencies\", {\n        get: function () {\n            return this.codeFrequency;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    CompressorHuffmanTree.prototype.setStaticCodes = function (codes, lengths) {\n        var temp = new Int16Array(codes.length);\n        temp.set(codes, 0);\n        this.codes = temp;\n        var lengthTemp = new Uint8Array(lengths.length);\n        lengthTemp.set(lengths, 0);\n        this.codeLength = lengthTemp;\n    };\n    /**\n     * reset all code data in tree\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.reset = function () {\n        for (var i = 0; i < this.codeFrequency.length; i++) {\n            this.codeFrequency[i] = 0;\n        }\n        this.codes = undefined;\n        this.codeLength = undefined;\n    };\n    /**\n     * write code to the compressor output stream\n     * @param {number} code - code to be written\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.writeCodeToStream = function (code) {\n        this.writer.pendingBufferWriteBits(this.codes[code] & 0xffff, this.codeLength[code]);\n    };\n    /**\n     * calculate code from their frequencies\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.buildCodes = function () {\n        var nextCode = new Int32Array(this.maxLength);\n        this.codes = new Int16Array(this.codeCount);\n        var code = 0;\n        for (var bitsCount = 0; bitsCount < this.maxLength; bitsCount++) {\n            nextCode[bitsCount] = code;\n            code += this.lengthCount[bitsCount] << (15 - bitsCount);\n        }\n        for (var i = 0; i < this.codeCount; i++) {\n            var bits = this.codeLength[i];\n            if (bits > 0) {\n                this.codes[i] = CompressorHuffmanTree.bitReverse(nextCode[bits - 1]);\n                nextCode[bits - 1] += 1 << (16 - bits);\n            }\n        }\n    };\n    CompressorHuffmanTree.bitReverse = function (value) {\n        return (CompressorHuffmanTree.reverseBits[value & 15] << 12\n            | CompressorHuffmanTree.reverseBits[(value >> 4) & 15] << 8\n            | CompressorHuffmanTree.reverseBits[(value >> 8) & 15] << 4\n            | CompressorHuffmanTree.reverseBits[value >> 12]);\n    };\n    /**\n     * calculate length of compressed data\n     * @returns {number}\n     */\n    CompressorHuffmanTree.prototype.getEncodedLength = function () {\n        var len = 0;\n        for (var i = 0; i < this.codeFrequency.length; i++) {\n            len += this.codeFrequency[i] * this.codeLength[i];\n        }\n        return len;\n    };\n    /**\n     * calculate code frequencies\n     * @param {CompressorHuffmanTree} blTree\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.calculateBLFreq = function (blTree) {\n        var maxCount;\n        var minCount;\n        var count;\n        var curLen = -1;\n        var i = 0;\n        while (i < this.codeCount) {\n            count = 1;\n            var nextLen = this.codeLength[i];\n            if (nextLen === 0) {\n                maxCount = 138;\n                minCount = 3;\n            }\n            else {\n                maxCount = 6;\n                minCount = 3;\n                if (curLen !== nextLen) {\n                    blTree.codeFrequency[nextLen]++;\n                    count = 0;\n                }\n            }\n            curLen = nextLen;\n            i++;\n            while (i < this.codeCount && curLen === this.codeLength[i]) {\n                i++;\n                if (++count >= maxCount) {\n                    break;\n                }\n            }\n            if (count < minCount) {\n                blTree.codeFrequency[curLen] += count;\n            }\n            else if (curLen !== 0) {\n                blTree.codeFrequency[16]++;\n            }\n            else if (count <= 10) {\n                blTree.codeFrequency[17]++;\n            }\n            else {\n                blTree.codeFrequency[18]++;\n            }\n        }\n    };\n    /**\n     * @param {CompressorHuffmanTree} blTree - write tree to output stream\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.writeTree = function (blTree) {\n        var maxRepeatCount;\n        var minRepeatCount;\n        var currentRepeatCount;\n        var currentCodeLength = -1;\n        var i = 0;\n        while (i < this.codeCount) {\n            currentRepeatCount = 1;\n            var nextLen = this.codeLength[i];\n            if (nextLen === 0) {\n                maxRepeatCount = 138;\n                minRepeatCount = 3;\n            }\n            else {\n                maxRepeatCount = 6;\n                minRepeatCount = 3;\n                if (currentCodeLength !== nextLen) {\n                    blTree.writeCodeToStream(nextLen);\n                    currentRepeatCount = 0;\n                }\n            }\n            currentCodeLength = nextLen;\n            i++;\n            while (i < this.codeCount && currentCodeLength === this.codeLength[i]) {\n                i++;\n                if (++currentRepeatCount >= maxRepeatCount) {\n                    break;\n                }\n            }\n            if (currentRepeatCount < minRepeatCount) {\n                while (currentRepeatCount-- > 0) {\n                    blTree.writeCodeToStream(currentCodeLength);\n                }\n            }\n            else if (currentCodeLength !== 0) {\n                blTree.writeCodeToStream(16);\n                this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 2);\n            }\n            else if (currentRepeatCount <= 10) {\n                blTree.writeCodeToStream(17);\n                this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 3);\n            }\n            else {\n                blTree.writeCodeToStream(18);\n                this.writer.pendingBufferWriteBits(currentRepeatCount - 11, 7);\n            }\n        }\n    };\n    /**\n     * Build huffman tree\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.buildTree = function () {\n        var codesCount = this.codeFrequency.length;\n        var arrTree = new Int32Array(codesCount);\n        var treeLength = 0;\n        var maxCount = 0;\n        for (var n = 0; n < codesCount; n++) {\n            var freq = this.codeFrequency[n];\n            if (freq !== 0) {\n                var pos = treeLength++;\n                var pPos = 0;\n                while (pos > 0 && this.codeFrequency[arrTree[pPos = Math.floor((pos - 1) / 2)]] > freq) {\n                    arrTree[pos] = arrTree[pPos];\n                    pos = pPos;\n                }\n                arrTree[pos] = n;\n                maxCount = n;\n            }\n        }\n        while (treeLength < 2) {\n            arrTree[treeLength++] =\n                (maxCount < 2) ? ++maxCount : 0;\n        }\n        this.codeCount = Math.max(maxCount + 1, this.codeMinCount);\n        var leafsCount = treeLength;\n        var nodesCount = leafsCount;\n        var child = new Int32Array(4 * treeLength - 2);\n        var values = new Int32Array(2 * treeLength - 1);\n        for (var i = 0; i < treeLength; i++) {\n            var node = arrTree[i];\n            var iIndex = 2 * i;\n            child[iIndex] = node;\n            child[iIndex + 1] = -1;\n            values[i] = (this.codeFrequency[node] << 8);\n            arrTree[i] = i;\n        }\n        this.constructHuffmanTree(arrTree, treeLength, values, nodesCount, child);\n        this.buildLength(child);\n    };\n    CompressorHuffmanTree.prototype.constructHuffmanTree = function (arrTree, treeLength, values, nodesCount, child) {\n        do {\n            var first = arrTree[0];\n            var last = arrTree[--treeLength];\n            var lastVal = values[last];\n            var pPos = 0;\n            var path = 1;\n            while (path < treeLength) {\n                if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {\n                    path++;\n                }\n                arrTree[pPos] = arrTree[path];\n                pPos = path;\n                path = pPos * 2 + 1;\n            }\n            while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {\n                arrTree[path] = arrTree[pPos];\n            }\n            arrTree[path] = last;\n            var second = arrTree[0];\n            last = nodesCount++;\n            child[2 * last] = first;\n            child[2 * last + 1] = second;\n            var minDepth = Math.min(values[first] & 0xff, values[second] & 0xff);\n            values[last] = lastVal = values[first] + values[second] - minDepth + 1;\n            pPos = 0;\n            path = 1;\n            /* tslint:disable */\n            while (path < treeLength) {\n                if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {\n                    path++;\n                }\n                arrTree[pPos] = arrTree[path];\n                pPos = path;\n                path = pPos * 2 + 1;\n            } /* tslint:disable */\n            while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {\n                arrTree[path] = arrTree[pPos];\n            }\n            arrTree[path] = last;\n        } while (treeLength > 1);\n    };\n    CompressorHuffmanTree.prototype.buildLength = function (child) {\n        this.codeLength = new Uint8Array(this.codeFrequency.length);\n        var numNodes = Math.floor(child.length / 2);\n        var numLeafs = Math.floor((numNodes + 1) / 2);\n        var overflow = 0;\n        for (var i = 0; i < this.maxLength; i++) {\n            this.lengthCount[i] = 0;\n        }\n        overflow = this.calculateOptimalCodeLength(child, overflow, numNodes);\n        if (overflow === 0) {\n            return;\n        }\n        var iIncreasableLength = this.maxLength - 1;\n        do {\n            while (this.lengthCount[--iIncreasableLength] === 0) {\n                /* tslint:disable */\n            }\n            do {\n                this.lengthCount[iIncreasableLength]--;\n                this.lengthCount[++iIncreasableLength]++;\n                overflow -= (1 << (this.maxLength - 1 - iIncreasableLength));\n            } while (overflow > 0 && iIncreasableLength < this.maxLength - 1);\n        } while (overflow > 0);\n        this.recreateTree(child, overflow, numLeafs);\n    };\n    CompressorHuffmanTree.prototype.recreateTree = function (child, overflow, numLeafs) {\n        this.lengthCount[this.maxLength - 1] += overflow;\n        this.lengthCount[this.maxLength - 2] -= overflow;\n        var nodePtr = 2 * numLeafs;\n        for (var bits = this.maxLength; bits !== 0; bits--) {\n            var n = this.lengthCount[bits - 1];\n            while (n > 0) {\n                var childPtr = 2 * child[nodePtr++];\n                if (child[childPtr + 1] === -1) {\n                    this.codeLength[child[childPtr]] = bits;\n                    n--;\n                }\n            }\n        }\n    };\n    CompressorHuffmanTree.prototype.calculateOptimalCodeLength = function (child, overflow, numNodes) {\n        var lengths = new Int32Array(numNodes);\n        lengths[numNodes - 1] = 0;\n        for (var i = numNodes - 1; i >= 0; i--) {\n            var childIndex = 2 * i + 1;\n            if (child[childIndex] !== -1) {\n                var bitLength = lengths[i] + 1;\n                if (bitLength > this.maxLength) {\n                    bitLength = this.maxLength;\n                    overflow++;\n                }\n                lengths[child[childIndex - 1]] = lengths[child[childIndex]] = bitLength;\n            }\n            else {\n                var bitLength = lengths[i];\n                this.lengthCount[bitLength - 1]++;\n                this.codeLength[child[childIndex - 1]] = lengths[i];\n            }\n        }\n        return overflow;\n    };\n    CompressorHuffmanTree.reverseBits = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15];\n    CompressorHuffmanTree.huffCodeLengthOrders = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n    return CompressorHuffmanTree;\n}());\nexport { CompressorHuffmanTree };\n/**\n * Checksum calculator, based on Adler32 algorithm.\n */\nvar ChecksumCalculator = /** @class */ (function () {\n    function ChecksumCalculator() {\n    }\n    /**\n     * Updates checksum by calculating checksum of the\n     * given buffer and adding it to current value.\n     * @param {number} checksum - current checksum.\n     * @param {Uint8Array} buffer - data byte array.\n     * @param {number} offset - offset in the buffer.\n     * @param {number} length - length of data to be used from the stream.\n     * @returns {number}\n     */\n    ChecksumCalculator.checksumUpdate = function (checksum, buffer, offset, length) {\n        var uint = new Uint32Array(1);\n        uint[0] = checksum;\n        var checksum_uint = uint[0];\n        var s1 = uint[0] = checksum_uint & 65535;\n        var s2 = uint[0] = checksum_uint >> ChecksumCalculator.checkSumBitOffset;\n        while (length > 0) {\n            var steps = Math.min(length, ChecksumCalculator.checksumIterationCount);\n            length -= steps;\n            while (--steps >= 0) {\n                s1 = s1 + (uint[0] = (buffer[offset++] & 255));\n                s2 = s2 + s1;\n            }\n            s1 %= ChecksumCalculator.checksumBase;\n            s2 %= ChecksumCalculator.checksumBase;\n        }\n        checksum_uint = (s2 << ChecksumCalculator.checkSumBitOffset) | s1;\n        return checksum_uint;\n    };\n    ChecksumCalculator.checkSumBitOffset = 16;\n    ChecksumCalculator.checksumBase = 65521;\n    ChecksumCalculator.checksumIterationCount = 3800;\n    return ChecksumCalculator;\n}());\nexport { ChecksumCalculator };\n","import { CompressedStreamWriter } from './compression-writer';\nimport { Save } from '@syncfusion/ej2-file-utils';\nvar CRC32TABLE = [];\n/**\n * class provide compression library\n * ```typescript\n * let archive = new ZipArchive();\n * archive.compressionLevel = 'Normal';\n * let archiveItem = new ZipArchiveItem(archive, 'directoryName\\fileName.txt');\n * archive.addItem(archiveItem);\n * archive.save(fileName.zip);\n * ```\n */\nvar ZipArchive = /** @class */ (function () {\n    /**\n     * constructor for creating ZipArchive instance\n     */\n    function ZipArchive() {\n        if (CRC32TABLE.length === 0) {\n            ZipArchive.initCrc32Table();\n        }\n        this.files = [];\n        this.level = 'Normal';\n        Save.isMicrosoftBrowser = !(!navigator.msSaveBlob);\n    }\n    Object.defineProperty(ZipArchive.prototype, \"compressionLevel\", {\n        /**\n         * gets compression level\n         */\n        get: function () {\n            return this.level;\n        },\n        /**\n         * sets compression level\n         */\n        set: function (level) {\n            this.level = level;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ZipArchive.prototype, \"length\", {\n        /**\n         * gets items count\n         */\n        get: function () {\n            if (this.files === undefined) {\n                return 0;\n            }\n            return this.files.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * add new item to archive\n     * @param {ZipArchiveItem} item - item to be added\n     * @returns {void}\n     */\n    ZipArchive.prototype.addItem = function (item) {\n        if (item === null || item === undefined) {\n            throw new Error('ArgumentException: item cannot be null or undefined');\n        }\n        for (var i = 0; i < this.files.length; i++) {\n            var file = this.files[i];\n            if (file instanceof ZipArchiveItem) {\n                if (file.name === item.name) {\n                    throw new Error('item with same name already exist');\n                }\n            }\n        }\n        this.files.push(item);\n    };\n    /**\n     * add new directory to archive\n     * @param directoryName directoryName to be created\n     * @returns {void}\n     */\n    ZipArchive.prototype.addDirectory = function (directoryName) {\n        if (directoryName === null || directoryName === undefined) {\n            throw new Error('ArgumentException: string cannot be null or undefined');\n        }\n        if (directoryName.length === 0) {\n            throw new Error('ArgumentException: string cannot be empty');\n        }\n        if (directoryName.slice(-1) !== '/') {\n            directoryName += '/';\n        }\n        if (this.files.indexOf(directoryName) !== -1) {\n            throw new Error('item with same name already exist');\n        }\n        this.files.push(directoryName);\n    };\n    /**\n     * gets item at specified index\n     * @param {number} index - item index\n     * @returns {ZipArchiveItem}\n     */\n    ZipArchive.prototype.getItem = function (index) {\n        if (index >= 0 && index < this.files.length) {\n            return this.files[index];\n        }\n        return undefined;\n    };\n    /**\n     * determines whether an element is in the collection\n     * @param {string | ZipArchiveItem} item - item to search\n     * @returns {boolean}\n     */\n    ZipArchive.prototype.contains = function (item) {\n        return this.files.indexOf(item) !== -1 ? true : false;\n    };\n    /**\n     * save archive with specified file name\n     * @param {string} fileName save archive with specified file name\n     * @returns {Promise<ZipArchive>}\n     */\n    ZipArchive.prototype.save = function (fileName) {\n        if (fileName === null || fileName === undefined || fileName.length === 0) {\n            throw new Error('ArgumentException: fileName cannot be null or undefined');\n        }\n        if (this.files.length === 0) {\n            throw new Error('InvalidOperation');\n        }\n        var zipArchive = this;\n        var promise;\n        return promise = new Promise(function (resolve, reject) {\n            zipArchive.saveInternal(fileName, false).then(function () {\n                resolve(zipArchive);\n            });\n        });\n    };\n    /**\n     * Save archive as blob\n     * @return {Promise<Blob>}\n     */\n    ZipArchive.prototype.saveAsBlob = function () {\n        var zipArchive = this;\n        var promise;\n        return promise = new Promise(function (resolve, reject) {\n            zipArchive.saveInternal('', true).then(function (blob) {\n                resolve(blob);\n            });\n        });\n    };\n    ZipArchive.prototype.saveInternal = function (fileName, skipFileSave) {\n        var _this = this;\n        var zipArchive = this;\n        var promise;\n        return promise = new Promise(function (resolve, reject) {\n            var zipData = [];\n            var dirLength = 0;\n            for (var i = 0; i < zipArchive.files.length; i++) {\n                var compressedObject = _this.getCompressedData(_this.files[i]);\n                compressedObject.then(function (data) {\n                    dirLength = zipArchive.constructZippedObject(zipData, data, dirLength, data.isDirectory);\n                    if (zipData.length === zipArchive.files.length) {\n                        var blob = zipArchive.writeZippedContent(fileName, zipData, dirLength, skipFileSave);\n                        resolve(blob);\n                    }\n                });\n            }\n        });\n    };\n    /**\n     * release allocated un-managed resource\n     * @returns {void}\n     */\n    ZipArchive.prototype.destroy = function () {\n        if (this.files !== undefined && this.files.length > 0) {\n            for (var i = 0; i < this.files.length; i++) {\n                var file = this.files[i];\n                if (file instanceof ZipArchiveItem) {\n                    file.destroy();\n                }\n                file = undefined;\n            }\n            this.files = [];\n        }\n        this.files = undefined;\n        this.level = undefined;\n    };\n    ZipArchive.prototype.getCompressedData = function (item) {\n        var zipArchive = this;\n        var promise = new Promise(function (resolve, reject) {\n            if (item instanceof ZipArchiveItem) {\n                var reader_1 = new FileReader();\n                reader_1.onload = function () {\n                    var input = new Uint8Array(reader_1.result);\n                    var data = {\n                        fileName: item.name, crc32Value: 0, compressedData: [],\n                        compressedSize: undefined, uncompressedDataSize: input.length, compressionType: undefined,\n                        isDirectory: false\n                    };\n                    if (zipArchive.level === 'Normal') {\n                        zipArchive.compressData(input, data, CRC32TABLE);\n                        var length_1 = 0;\n                        for (var i = 0; i < data.compressedData.length; i++) {\n                            length_1 += data.compressedData[i].length;\n                        }\n                        data.compressedSize = length_1;\n                        data.compressionType = '\\x08\\x00'; //Deflated = 8\n                    }\n                    else {\n                        data.compressedSize = input.length;\n                        data.crc32Value = zipArchive.calculateCrc32Value(0, input, CRC32TABLE);\n                        data.compressionType = '\\x00\\x00'; // Stored = 0\n                        data.compressedData.push(input);\n                    }\n                    resolve(data);\n                };\n                reader_1.readAsArrayBuffer(item.data);\n            }\n            else {\n                var data = {\n                    fileName: item, crc32Value: 0, compressedData: '', compressedSize: 0, uncompressedDataSize: 0,\n                    compressionType: '\\x00\\x00', isDirectory: true\n                };\n                resolve(data);\n            }\n        });\n        return promise;\n    };\n    ZipArchive.prototype.compressData = function (input, data, crc32Table) {\n        var compressor = new CompressedStreamWriter(true);\n        var currentIndex = 0;\n        var nextIndex = 0;\n        do {\n            if (currentIndex >= input.length) {\n                compressor.close();\n                break;\n            }\n            nextIndex = Math.min(input.length, currentIndex + 16384);\n            var subArray = input.subarray(currentIndex, nextIndex);\n            data.crc32Value = this.calculateCrc32Value(data.crc32Value, subArray, crc32Table);\n            compressor.write(subArray, 0, nextIndex - currentIndex);\n            currentIndex = nextIndex;\n        } while (currentIndex <= input.length);\n        data.compressedData = compressor.compressedData;\n        compressor.destroy();\n    };\n    ZipArchive.prototype.constructZippedObject = function (zipParts, data, dirLength, isDirectory) {\n        var extFileAttr = 0;\n        var date = new Date();\n        if (isDirectory) {\n            extFileAttr = extFileAttr | 0x00010; // directory flag\n        }\n        extFileAttr = extFileAttr | (0 & 0x3F);\n        var header = this.writeHeader(data, date);\n        var localHeader = 'PK\\x03\\x04' + header + data.fileName;\n        var centralDir = this.writeCentralDirectory(data, header, dirLength, extFileAttr);\n        zipParts.push({ localHeader: localHeader, centralDir: centralDir, compressedData: data });\n        return dirLength + localHeader.length + data.compressedSize;\n    };\n    ZipArchive.prototype.writeHeader = function (data, date) {\n        var zipHeader = '';\n        zipHeader += '\\x0A\\x00' + '\\x00\\x00'; // version needed to extract & general purpose bit flag\n        zipHeader += data.compressionType; // compression method Deflate=8,Stored=0\n        zipHeader += this.getBytes(this.getModifiedTime(date), 2); // last modified Time\n        zipHeader += this.getBytes(this.getModifiedDate(date), 2); // last modified date\n        zipHeader += this.getBytes(data.crc32Value, 4); // crc-32 value\n        zipHeader += this.getBytes(data.compressedSize, 4); // compressed file size\n        zipHeader += this.getBytes(data.uncompressedDataSize, 4); // uncompressed file size\n        zipHeader += this.getBytes(data.fileName.length, 2); // file name length\n        zipHeader += this.getBytes(0, 2); // extra field length\n        return zipHeader;\n    };\n    ZipArchive.prototype.writeZippedContent = function (fileName, zipData, localDirLen, skipFileSave) {\n        var cenDirLen = 0;\n        var buffer = [];\n        for (var i = 0; i < zipData.length; i++) {\n            var item = zipData[i];\n            cenDirLen += item.centralDir.length;\n            buffer.push(this.getArrayBuffer(item.localHeader));\n            while (item.compressedData.compressedData.length) {\n                buffer.push(item.compressedData.compressedData.shift().buffer);\n            }\n        }\n        for (var i = 0; i < zipData.length; i++) {\n            buffer.push(this.getArrayBuffer(zipData[i].centralDir));\n        }\n        buffer.push(this.getArrayBuffer(this.writeFooter(zipData, cenDirLen, localDirLen)));\n        var blob = new Blob(buffer, { type: 'application/zip' });\n        if (!skipFileSave) {\n            Save.save(fileName, blob);\n        }\n        return blob;\n    };\n    ZipArchive.prototype.writeCentralDirectory = function (data, localHeader, offset, externalFileAttribute) {\n        var directoryHeader = 'PK\\x01\\x02' +\n            this.getBytes(0x0014, 2) + localHeader + // inherit from file header\n            this.getBytes(0, 2) + // comment length\n            '\\x00\\x00' + '\\x00\\x00' + // internal file attributes \n            this.getBytes(externalFileAttribute, 4) + // external file attributes\n            this.getBytes(offset, 4) + // local fileHeader relative offset\n            data.fileName;\n        return directoryHeader;\n    };\n    ZipArchive.prototype.writeFooter = function (zipData, centralLength, localLength) {\n        var dirEnd = 'PK\\x05\\x06' + '\\x00\\x00' + '\\x00\\x00' +\n            this.getBytes(zipData.length, 2) + this.getBytes(zipData.length, 2) +\n            this.getBytes(centralLength, 4) + this.getBytes(localLength, 4) +\n            this.getBytes(0, 2);\n        return dirEnd;\n    };\n    ZipArchive.prototype.getArrayBuffer = function (input) {\n        var a = new Uint8Array(input.length);\n        for (var j = 0; j < input.length; ++j) {\n            a[j] = input.charCodeAt(j) & 0xFF;\n        }\n        return a.buffer;\n    };\n    ZipArchive.prototype.getBytes = function (value, offset) {\n        var bytes = '';\n        for (var i = 0; i < offset; i++) {\n            bytes += String.fromCharCode(value & 0xff);\n            value = value >>> 8;\n        }\n        return bytes;\n    };\n    ZipArchive.prototype.getModifiedTime = function (date) {\n        var modTime = date.getHours();\n        modTime = modTime << 6;\n        modTime = modTime | date.getMinutes();\n        modTime = modTime << 5;\n        return modTime = modTime | date.getSeconds() / 2;\n    };\n    ZipArchive.prototype.getModifiedDate = function (date) {\n        var modiDate = date.getFullYear() - 1980;\n        modiDate = modiDate << 4;\n        modiDate = modiDate | (date.getMonth() + 1);\n        modiDate = modiDate << 5;\n        return modiDate = modiDate | date.getDate();\n    };\n    ZipArchive.prototype.calculateCrc32Value = function (crc32Value, input, crc32Table) {\n        crc32Value ^= -1;\n        for (var i = 0; i < input.length; i++) {\n            crc32Value = (crc32Value >>> 8) ^ crc32Table[(crc32Value ^ input[i]) & 0xFF];\n        }\n        return (crc32Value ^ (-1));\n    };\n    /**\n     * construct cyclic redundancy code table\n     * @private\n     */\n    ZipArchive.initCrc32Table = function () {\n        var i;\n        for (var j = 0; j < 256; j++) {\n            i = j;\n            for (var k = 0; k < 8; k++) {\n                i = ((i & 1) ? (0xEDB88320 ^ (i >>> 1)) : (i >>> 1));\n            }\n            CRC32TABLE[j] = i;\n        }\n    };\n    return ZipArchive;\n}());\nexport { ZipArchive };\n/**\n * Class represent unique ZipArchive item\n * ```typescript\n * let archiveItem = new ZipArchiveItem(archive, 'directoryName\\fileName.txt');\n * ```\n */\nvar ZipArchiveItem = /** @class */ (function () {\n    /**\n     * constructor for creating {ZipArchiveItem} instance\n     * @param {Blob|ArrayBuffer} data file data\n     * @param {itemName} itemName absolute file path\n     */\n    function ZipArchiveItem(data, itemName) {\n        if (data === null || data === undefined) {\n            throw new Error('ArgumentException: data cannot be null or undefined');\n        }\n        if (itemName === null || itemName === undefined) {\n            throw new Error('ArgumentException: string cannot be null or undefined');\n        }\n        if (itemName.length === 0) {\n            throw new Error('string cannot be empty');\n        }\n        this.data = data;\n        this.name = itemName;\n    }\n    Object.defineProperty(ZipArchiveItem.prototype, \"name\", {\n        /**\n         * Get the name of archive item\n         * @returns string\n         */\n        get: function () {\n            return this.fileName;\n        },\n        /**\n         * Set the name of archive item\n         * @param  {string} value\n         */\n        set: function (value) {\n            this.fileName = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * release allocated un-managed resource\n     * @returns {void}\n     */\n    ZipArchiveItem.prototype.destroy = function () {\n        this.fileName = undefined;\n        this.data = undefined;\n    };\n    return ZipArchiveItem;\n}());\nexport { ZipArchiveItem };\n"],"names":["ARR_LITERAL_CODES","Int16Array","ARR_LITERAL_LENGTHS","Uint8Array","ARR_DISTANCE_CODES","ARR_DISTANCE_LENGTHS","CompressedStreamWriter","noWrap","this","pendingBuffer","pendingBufLength","pendingBufCache","pendingBufBitsInCache","bufferPosition","extraBits","currentHash","matchStart","matchLength","matchPrevAvail","blockStart","stringStart","lookAhead","totalBytesIn","inputOffset","inputEnd","windowSize","windowMask","hashSize","hashMask","hashShift","Math","floor","maxDist","checkSum","isHuffmanTreeInitiated","initHuffmanTree","treeLiteral","CompressorHuffmanTree","treeDistances","treeCodeLengths","arrDistances","Uint16Array","arrLiterals","stream","dataWindow","hashHead","hashPrevious","writeZLibHeader","Object","defineProperty","prototype","get","enumerable","configurable","compressedString","undefined","i","length","String","fromCharCode","apply","write","data","offset","Error","end","encode","Encoding","type","getBytes","inputBuffer","ChecksumCalculator","checksumUpdate","pendingBufferFlush","compressData","headerDate","pendingBufferWriteShortBytes","s","finish","success","fillWindow","canFlush","compressSlow","flush","lookAheadCompleted","slideWindow","prevMatch","prevLen","discardMatch","matchPreviousBest","matchPreviousAvailable","huffmanIsFull","insertString","findLongestMatch","huffmanTallyLit","huffmanTallyDist","huffmanFlushBlock","len","lastBlock","more","set","subarray","updateHash","m","match","hash","curMatch","chainLen","niceLen","scan","bestEnd","bestLength","max","limit","stringEnd","scanEnd1","scanEnd","min","literal","codeFrequencies","dist","lc","huffmanLengthCode","dc","huffmanDistanceCode","stored","storedOffset","storedLength","buildTree","calculateBLFreq","blTreeCodes","codeLengths","huffCodeLengthOrders","opt_len","getEncodedLength","static_len","huffmanFlushStoredBlock","pendingBufferWriteBits","setStaticCodes","huffmanCompressBlock","huffmanReset","huffmanSendAllTrees","pendingBufferAlignToByte","pendingBufferWriteShort","pendingBufferWriteByteBlock","code","distance","buildCodes","treeLength","rank","writeTree","reset","literalLen","writeCodeToStream","bits","b","count","uint","Uint32Array","pendingBufferFlushBits","isClose","array","push","result","bitReverse","close","destroy","writer","elementCount","minCodes","maxLength","codeMinCount","codeFrequency","lengthCount","Int32Array","codeCount","codeLength","codes","lengths","temp","lengthTemp","nextCode","bitsCount","value","reverseBits","blTree","maxCount","minCount","curLen","nextLen","maxRepeatCount","minRepeatCount","currentRepeatCount","currentCodeLength","codesCount","arrTree","n","freq","pos","pPos","nodesCount","child","values","node","iIndex","constructHuffmanTree","buildLength","first","last","lastVal","path","second","minDepth","numNodes","numLeafs","overflow","calculateOptimalCodeLength","iIncreasableLength","recreateTree","nodePtr","childPtr","childIndex","bitLength","checksum","buffer","checksum_uint","s1","s2","checkSumBitOffset","steps","checksumIterationCount","checksumBase","CRC32TABLE","ZipArchive","initCrc32Table","files","level","Save","isMicrosoftBrowser","navigator","msSaveBlob","addItem","item","file","ZipArchiveItem","name","addDirectory","directoryName","slice","indexOf","getItem","index","contains","save","fileName","zipArchive","Promise","resolve","reject","saveInternal","then","saveAsBlob","blob","skipFileSave","_this","zipData","dirLength","getCompressedData","constructZippedObject","isDirectory","writeZippedContent","reader_1","FileReader","onload","input","crc32Value","compressedData","compressedSize","uncompressedDataSize","compressionType","length_1","calculateCrc32Value","readAsArrayBuffer","crc32Table","compressor","currentIndex","nextIndex","subArray","zipParts","extFileAttr","date","Date","header","writeHeader","localHeader","centralDir","writeCentralDirectory","zipHeader","getModifiedTime","getModifiedDate","localDirLen","cenDirLen","getArrayBuffer","shift","writeFooter","Blob","externalFileAttribute","centralLength","localLength","a","j","charCodeAt","bytes","modTime","getHours","getMinutes","getSeconds","modiDate","getFullYear","getMonth","getDate","k","itemName"],"mappings":"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"}